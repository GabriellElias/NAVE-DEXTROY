<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nave Espacial 2D</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');

        body {
            margin: 0;
            overflow: hidden; /* Prevent all scrolling, including horizontal */
            background-color: #050510;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Share Tech Mono', monospace; /* Tech font */
            color: #eee;
            flex-direction: column;
            transition: background-color 0.5s ease;
        }

        /* Heartbeat effect for Hunter Boss */
        #darkness-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            opacity: 0;
            z-index: 25; /* Above canvas, below menus */
            pointer-events: none;
            transition: opacity 1s ease-in-out;
        }

        body.apocalypse-active #darkness-overlay {
            opacity: 0.9;
            animation: heartbeatPulse 1.2s infinite ease-in-out;
        }

        @keyframes heartbeatPulse {
            0% { opacity: 0.95; }
            50% { opacity: 0.8; }
            100% { opacity: 0.95; }
        }


        /* Orientation Message */
        #orientation-message {
            display: none; /* Hidden by default, shown by JS */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            color: #00ff00;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8em;
            text-align: center;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
            padding: 20px;
            box-sizing: border-box;
            text-shadow: 0 0 10px #00ff00;
        }
        #orientation-message svg {
            width: 80px;
            height: 80px;
            fill: #00ff00;
            margin-bottom: 20px;
            animation: rotateHint 2s infinite ease-in-out;
        }

        @keyframes rotateHint {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
            100% { transform: rotate(0deg); }
        }


        #main-screen, #tutorial-screen, #game-over-screen, #challenge-modal {
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 15px;
            border: 3px solid #0f0;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.8);
            text-align: center;
            z-index: 30;
            max-width: 800px;
            width: 90%;
            display: flex;
            flex-direction: column;
            gap: 20px;
            position: relative;
            animation: fadeIn 0.5s ease-out;
        }

        #challenge-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none; /* Hidden by default */
            border-color: #ff0000;
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.9);
            animation: fadeIn 0.3s ease-out, flicker-red 1s infinite;
        }
        
        #challenge-modal h2 {
            color: #ff4444;
            font-family: 'Orbitron', sans-serif;
        }

        #challenge-modal p {
            color: #ddd;
            font-size: 1.2em;
        }

        @keyframes flicker-red {
            0%   { border-color: #ff0000; box-shadow: 0 0 40px rgba(255, 0, 0, 0.9); }
            50%  { border-color: #990000; box-shadow: 0 0 20px rgba(255, 0, 0, 0.5); }
            100% { border-color: #ff0000; box-shadow: 0 0 40px rgba(255, 0, 0, 0.9); }
        }

        .challenge-button, .cancel-button {
            background-color: #8B0000;
        }

        .challenge-button:hover {
             background-color: #B80000;
        }

        .cancel-button {
            background-color: #555;
        }
        .cancel-button:hover {
            background-color: #777;
        }

        #main-screen h1, #tutorial-screen h2, #game-over-screen h2 {
            font-family: 'Orbitron', sans-serif; /* Futuristic font for titles */
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00, 0 0 20px rgba(0, 255, 0, 0.5);
            margin-bottom: 20px;
            letter-spacing: 2px;
        }

        #player-name-input {
            padding: 12px;
            border: 2px solid #0f0;
            background-color: rgba(0, 0, 0, 0.6);
            color: #eee;
            font-size: 1.2em;
            width: calc(100% - 24px);
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0, 255, 0, 0.5);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        #player-name-input:focus {
            border-color: #00ffff;
            box-shadow: inset 0 0 8px rgba(0, 255, 255, 0.7);
            outline: none;
        }

        .button-group {
            display: flex;
            justify-content: center;
            gap: 25px;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
        }

        .main-button {
            background-color: #008000;
            color: white;
            padding: 18px 35px;
            border: none;
            border-radius: 8px;
            font-size: 1.3em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 0 12px rgba(0, 255, 0, 0.6);
            text-transform: uppercase;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
        }

        .main-button:hover {
            background-color: #00b300;
            transform: translateY(-3px);
            box-shadow: 0 0 18px rgba(0, 255, 0, 0.9);
        }
        .main-button:active {
            transform: translateY(0);
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.4);
        }

        #high-scores {
            margin-top: 30px;
            border-top: 2px solid rgba(0, 255, 0, 0.4);
            padding-top: 25px;
        }

        #high-scores h2 {
            font-family: 'Orbitron', sans-serif;
            color: #00ffff;
            text-shadow: 0 0 8px #00ffff;
            margin-bottom: 18px;
            letter-spacing: 1.5px;
        }

        #high-scores table {
            width: 100%;
            border-collapse: collapse;
            margin: 0 auto;
            color: #eee;
            font-size: 1.1em;
        }

        #high-scores th, #high-scores td {
            border: 1px solid rgba(0, 255, 0, 0.3);
            padding: 12px;
            text-align: left;
        }

        #high-scores th {
            background-color: rgba(0, 255, 0, 0.15);
            color: #00ff00;
            font-weight: bold;
        }

        #high-scores td {
            background-color: rgba(0, 0, 0, 0.5);
        }
        #high-scores tr:nth-child(even) td {
            background-color: rgba(0, 0, 0, 0.6);
        }
        #high-scores tr:first-child td { /* Highlight top score */
            color: #ffd700;
            font-weight: bold;
            text-shadow: 0 0 5px #ffd700;
        }

        /* Tutorial Screen */
        #tutorial-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            height: 80%;
            overflow-y: auto;
            display: none;
            flex-direction: column;
            gap: 20px;
            padding: 30px; /* Adjust padding for better scroll */
        }
        #tutorial-screen::-webkit-scrollbar {
            width: 8px;
        }
        #tutorial-screen::-webkit-scrollbar-track {
            background: rgba(0, 255, 0, 0.1);
            border-radius: 10px;
        }
        #tutorial-screen::-webkit-scrollbar-thumb {
            background-color: #00ff00;
            border-radius: 10px;
            border: 2px solid rgba(0, 0, 0, 0.5);
        }


        #tutorial-screen h2 {
            margin-bottom: 15px;
            font-family: 'Orbitron', sans-serif;
            color: #00ff00;
            text-shadow: 0 0 8px #00ff00;
            letter-spacing: 1.5px;
        }

        #tutorial-screen .section {
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 0, 0.5);
            text-align: left;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        #tutorial-screen .section h3 {
            color: #ffd700;
            margin-top: 0;
            margin-bottom: 12px;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.7);
        }

        #tutorial-screen .section p, #tutorial-screen .section ul li {
            font-size: 1.05em;
            line-height: 1.7;
            color: #e0e0e0;
        }

        #tutorial-screen .section p strong {
            color: #00ffff;
            text-shadow: 0 0 3px #00ffff;
        }
        #tutorial-screen .section ul {
            list-style: none;
            padding: 0;
            margin-top: 10px;
        }
        #tutorial-screen .section ul li {
            margin-bottom: 10px;
            padding-left: 15px;
            position: relative;
        }
        #tutorial-screen .section ul li::before {
            content: '•';
            color: #00ff00;
            position: absolute;
            left: 0;
            font-size: 1.2em;
            line-height: 1;
        }
        #tutorial-screen .section ul li strong {
            color: #aaffaa;
            text-shadow: 0 0 2px #aaffaa;
        }
        #tutorial-screen .back-button {
            margin-top: 25px;
            background-color: #880000;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 6px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            align-self: center;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 0.8px;
        }
        #tutorial-screen .back-button:hover {
            background-color: #b30000;
            transform: translateY(-2px);
        }

        /* Game Over Screen */
        #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 30;
        }
        #game-over-screen p {
            font-size: 1.8em;
            color: #ff3333;
            text-shadow: 0 0 12px #ff0000;
            margin-bottom: 25px;
            font-family: 'Orbitron', sans-serif;
        }
        #final-score {
            font-size: 2.5em;
            color: #00ff00;
            font-weight: bold;
            text-shadow: 0 0 20px #00ff00, 0 0 30px rgba(0, 255, 0, 0.7);
        }

        /* Bottom Bar Menu */
        #bottom-bar-menu {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 10px; /* Increased padding */
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 0, 0.5);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 10px 8px; /* Increased gap */
            font-family: 'Share Tech Mono', monospace;
            color: #E0E0E0;
            display: none; /* Controlled by JS */
            max-width: 98%; /* Ensure it doesn't exceed screen width */
            height: auto;
        }

        /* Styling for simplified mobile menu bar */
        #bottom-bar-menu.mobile-simplified {
            bottom: 2px;
            padding: 3px 4px;
            gap: 3px 3px;
            max-width: 95%;
            height: 38px;
            flex-wrap: nowrap;
            justify-content: space-around;
        }
        #bottom-bar-menu.mobile-simplified .menu-item {
            min-width: 35px;
            height: 32px;
            font-size: 0.65em;
            padding: 0 1px;
        }
        #bottom-bar-menu.mobile-simplified .menu-item .label {
            font-size: 0.5em;
            margin-bottom: 0px;
        }
        #bottom-bar-menu.mobile-simplified .menu-item span:not(.label) {
            font-size: 0.7em;
        }
        #bottom-bar-menu.mobile-simplified .menu-item svg {
            width: 12px;
            height: 12px;
            margin-bottom: 0px;
        }


        .menu-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 60px; /* Increased min-width */
            height: 50px; /* Increased height */
            padding: 5px; /* Increased padding */
            border: 1px solid rgba(0, 255, 0, 0.2);
            border-radius: 6px;
            background-color: rgba(0, 0, 0, 0.3);
            box-shadow: inset 0 0 3px rgba(0, 255, 0, 0.1);
            font-size: 0.9em; /* Increased font size */
            text-align: center;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .menu-item:hover {
            background-color: rgba(0, 255, 0, 0.08);
            transform: translateY(-1px);
        }

        .menu-item .label {
            font-size: 0.7em; /* Increased label font size */
            color: #999;
            margin-bottom: 2px; /* Increased margin */
            white-space: nowrap;
        }

        .menu-item span:not(.label) {
            font-weight: bold;
            color: #0f0;
            font-size: 1em; /* Increased value font size */
            white-space: nowrap;
        }

        .menu-item svg {
            margin-bottom: 2px; /* Increased margin */
            width: 20px; /* Increased icon size */
            height: 20px; /* Increased icon size */
        }

        /* Specific styles for ability/power-up status */
        .ready {
            color: #00ff00;
            font-weight: bold;
            text-shadow: 0 0 2px #00ff00;
        }
        .active {
            color: #00ffff;
            font-weight: bold;
            text-shadow: 0 0 4px #00ffff;
        }
        .recharging {
            color: #ffaa00;
            font-size: 0.9em !important; /* Adjusted for new font size */
        }
        .not-ready {
            color: #888;
        }
        
        .missile-display {
            display: inline-block;
            margin: 0 2px; /* Adjusted margin */
            font-weight: normal;
            font-size: 0.9em; /* Adjusted font size */
        }
        .missile-display.ready {
            color: #00ff00;
        }
        .missile-display.recharging {
            color: #ffaa00;
        }

        canvas {
            background-color: transparent;
            cursor: none;
            border: 2px solid #0f0;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
            display: none; /* Controlled by JS */
            z-index: 1; /* Ensure canvas is behind other elements */
        }

        #reticle {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid yellow;
            border-radius: 50%;
            pointer-events: none;
            z-index: 20;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px yellow, 0 0 15px rgba(255, 255, 0, 0.5);
            display: none; /* Controlled by JS */
            transition: transform 0.05s linear;
        }

        #reticle::before, #reticle::after {
            content: '';
            position: absolute;
            background-color: yellow;
            box-shadow: 0 0 4px yellow;
        }

        #reticle::before {
            width: 25px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #reticle::after {
            width: 2px;
            height: 25px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Keyframe Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes pulseShield {
            0% { box-shadow: 0 0 10px rgba(0, 200, 255, 0.7); }
            50% { box-shadow: 0 0 25px rgba(0, 200, 255, 0.9), 0 0 40px rgba(0, 200, 255, 0.5); }
            100% { box-shadow: 0 0 10px rgba(0, 200, 255, 0.7); }
        }

        /* SVG Icon Styles for in-game use */
        .icon {
            fill: currentColor;
            width: 1em;
            height: 1em;
            vertical-align: -0.125em;
            pointer-events: none;
        }
        .icon-small {
            width: 1.1em;
            height: 1.1em;
        }

        /* Specific colors for pickup icons */
        .pickup-icon-life { color: limegreen; }
        .pickup-icon-shield { color: dodgerblue; }
        .pickup-icon-drone { color: gold; }
        .pickup-icon-missile { color: red; }
        .pickup-icon-bomb { color: darkviolet; }
        .pickup-icon-rapidfire { color: hotpink; }
        .pickup-icon-tripleshot { color: orange; }

        /* Icon for menu items */
        .menu-icon-score { fill: #0f0; }
        .menu-icon-wave { fill: #00ffff; }
        .menu-icon-lives { fill: limegreen; }
        .menu-icon-shield { fill: #99f; }
        .menu-icon-energy { fill: #ffd700; }
        .menu-icon-drone-points { fill: #a020f0; }
        .menu-icon-missile { fill: red; }
        .menu-icon-dash { fill: #add8e6; }
        .menu-icon-bomb { fill: #8B008B; }
        .menu-icon-defense-drone { fill: #B22222; }
        .menu-icon-rapidfire { fill: hotpink; }
        .menu-icon-tripleshot { fill: orange; }
        .menu-icon-predator { fill: #FFD700; }
        .menu-icon-multiplier { fill: #f0f; }


        /* Mobile Controls Overlay */
        #mobile-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50; /* Ensure this is above canvas but below other UI elements if they have z-index */
            pointer-events: none; /* Allows clicks to pass through by default, child elements enable it */
            display: none; /* Hidden by default, shown by JS */
        }

        /* Joystick */
        #joystick-area {
            position: absolute;
            bottom: 100px; /* Moved up from 80px */
            left: 80px; /* Moved right from 40px */
            width: 90px; 
            height: 90px; 
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(0, 255, 0, 0.6);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 51; 
            pointer-events: all;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.4);
            transition: box-shadow 0.2s ease;
        }
        #joystick-area.active {
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.8), 0 0 30px rgba(0, 255, 0, 0.5);
        }

        #joystick-inner {
            width: 35px; 
            height: 35px; 
            background: rgba(0, 255, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(0px, 0px);
            transition: transform 0.05s linear, background-color 0.2s ease;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.8);
        }
        #joystick-inner.active {
            background-color: #00ffff; /* Change color when active */
        }

        /* Tap-to-Fire area */
        #tap-to-fire-area {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* Covers entire canvas */
            height: 100%; /* Covers entire canvas */
            pointer-events: all; /* Allows touch events on its surface */
            background: transparent; /* Ensure it's invisible */
        }

        /* Ability buttons container (GRID layout) */
        #ability-buttons-container {
            position: absolute;
            bottom: 100px; /* Moved up from 80px */
            right: 80px; /* Moved left from 40px */
            display: grid; 
            grid-template-columns: repeat(2, 1fr); 
            grid-template-rows: repeat(4, 1fr); 
            gap: 8px; 
            width: auto; 
            max-width: 100px; 
            z-index: 51; 
            pointer-events: all; 
        }

        .ability-button {
            width: 40px; 
            height: 40px;
            font-size: 0.6em; 
            padding: 0;
            border-radius: 8px; 
            background-color: #333;
            color: #eee;
            border: 1px solid #555;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 8px rgba(50, 50, 200, 0.5);
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        .ability-button:active {
            transform: scale(0.95);
        }
        .ability-button svg {
            width: 18px; 
            height: 18px;
            margin-bottom: 0px;
        }

        /* Adjust main menu and game over screens for smaller screens */
        @media (max-width: 768px) {
            #main-screen, #tutorial-screen, #game-over-screen {
                padding: 20px;
                gap: 15px;
            }
            #main-screen h1, #tutorial-screen h2, #game-over-screen h2 {
                font-size: 1.8em;
                margin-bottom: 15px;
            }
            .main-button {
                padding: 12px 25px;
                font-size: 1.1em;
            }
            #high-scores h2 {
                font-size: 1.4em;
                margin-bottom: 10px;
            }
            #high-scores table {
                font-size: 0.9em;
            }
            #high-scores th, #high-scores td {
                padding: 8px;
            }
            #player-name-input {
                font-size: 1em;
                padding: 10px;
            }
            #final-score {
                font-size: 2em;
            }
            #tutorial-screen .section h3 {
                font-size: 1.1em;
            }
            #tutorial-screen .section p, #tutorial-screen .section ul li {
                font-size: 0.9em;
            }
        }

        /* Disable user select on touch controls */
        #joystick-area, #tap-to-fire-area, .ability-button {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="darkness-overlay"></div>
    <div id="svg-icons" style="display: none;">
        <svg id="icon-life" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/></svg>
        <svg id="icon-shield" viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.29-3.58 8.16-7 9.87V12H5V5.27L12 2.2z"/></svg>
        <svg id="icon-drone" viewBox="0 0 24 24" fill="currentColor"><path d="M16 9h-3V5h-2v4H8l4 4zm-1 8h-2v-4h-2v4H7l4 4zm6-7v2h3v-2h-3zm-14 0v2H2v-2h3zM12 0c-6.63 0-12 5.37-12 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0z"/></svg>
        <svg id="icon-missile" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L6 8h12zm0 20l6-6H6zM15 11h-2V7h-2v4H9l3 3zm0 2v4h-2v-4h-2l3-3z"/></svg>
        <svg id="icon-bomb" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v2h-2zm0 4h2v6h-2z"/></svg>
        <svg id="icon-rapidfire" viewBox="0 0 24 24" fill="currentColor"><path d="M12 11c1.66 0 2.99-1.34 2.99-3S13.66 5 12 5 9.01 6.34 9.01 8s1.33 3 2.99 3zm0 9c-1.66 0-2.99-1.34-2.99-3S10.34 14 12 14s2.99 1.34 2.99 3-1.33 3-2.99 3zm0-14c1.66 0 2.99-1.34 2.99-3S13.66 0 12 0 9.01 1.34 9.01 3s1.33 3 2.99 3z"/></svg>
        <svg id="icon-tripleshot" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-8zm0 18c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/></svg>
        <svg id="icon-score" viewBox="0 0 24 24" fill="currentColor"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>
        <svg id="icon-wave" viewBox="0 0 24 24" fill="currentColor"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4c-3.72 0-6.81 2.87-7.25 6.5-.83 2.37.6 4.76 2.7 5.75C8.03 17.59 9.87 18 12 18h7.5c2.21 0 4-1.79 4-4s-1.79-4-4-4z"/></svg>
        <svg id="icon-energy" viewBox="0 0 24 24" fill="currentColor"><path d="M17 4h-3V2h-4v2H7v18h10V4zm-2 16H9V6h6v14z"/></svg>
        <svg id="icon-defense-drone" viewBox="0 0 24 24" fill="currentColor"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.31-.61-.22l-2.49 1c-.52-.39-1.09-.7-1.71-.94L14 2.1c-.05-.2-.25-.3-.46-.3h-4c-.21 0-.4.1-.45.3L9.03 5.05c-.62.24-1.19.55-1.71.94l-2.49-1c-.22-.09-.49 0-.61.22l-2 3.46c-.12.22-.07.49.12.64l2.11 1.65c-.04.32-.07.64-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24-.42-.12-.64l2 3.46c-.12.22.39.31.61.22l2.49-1c.52.39 1.09.7 1.71.94L9.03 21.9c.05.2.25.3.46.3h4c-.21 0 .4-.1.45.3l.36-2.81c.62-.24 1.19-.55 1.71-.94l2.49 1c-.22.09-.49 0 .61.22l2-3.46c.12.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
        <svg id="icon-multiplier" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9V8h2v8zm4 0h-2V8h2v8z"/></svg>
        <svg id="icon-rotate-device" viewBox="0 0 24 24" fill="currentColor"><path d="M15.5 17h-7l1.37-1.37c-.64-.47-1.1-1.07-1.38-1.77L6 14.5c.6 1.73 1.96 3.14 3.73 3.99L10 20.5h4.5l-1.37-1.37c.64-.47 1.1-1.07 1.38-1.77l.5-.5c-.6-1.73-1.96-3.14-3.73-3.99zm-4.73-9.5c.6-.47 1.1-1.07 1.38-1.77l.5-.5c-.6-1.73-1.96-3.14-3.73-3.99L6 3.5h7l-1.37 1.37c.64.47 1.1 1.07 1.38 1.77l.5.5c-.6 1.73-1.96-3.14-3.73 3.99zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"/></svg>
    </div>

    <div id="orientation-message">
        <svg><use xlink:href="#icon-rotate-device"></use></svg>
        <p>Por favor, gire seu dispositivo para a orientação horizontal para jogar.</p>
    </div>

    <div id="main-screen">
        <h1>Nave Espacial 2D</h1>
        <input type="text" id="player-name-input" placeholder="Seu nome (opcional)" maxlength="15">
        
        <div class="button-group">
            <button id="play-normal-pc-button" class="main-button">Jogar (PC)</button>
            <button id="play-normal-mobile-button" class="main-button">Jogar (Celular)</button>
        </div>
        <div class="button-group">
            <button id="challenge-button" class="main-button challenge-button">Modo Desafio</button>
            <button id="tutorial-button" class="main-button">Tutorial</button>
        </div>

        <div id="high-scores">
            <h2>Recordes</h2>
            <table>
                <thead>
                    <tr>
                        <th>Posição</th>
                        <th>Nome</th>
                        <th>Pontos</th>
                    </tr>
                </thead>
                <tbody id="high-scores-body">
                    </tbody>
            </table>
        </div>
    </div>
    
    <div id="challenge-modal">
        <h2>Modo Desafio</h2>
        <p>Você está prestes a entrar em uma simulação de alto risco. A dificuldade é extrema, a sobrevivência é improvável. Continuar?</p>
        <div class="button-group">
            <button id="confirm-challenge-pc-button" class="main-button challenge-button">Aceitar (PC)</button>
            <button id="confirm-challenge-mobile-button" class="main-button challenge-button">Aceitar (Celular)</button>
        </div>
         <div class="button-group">
            <button id="cancel-challenge-button" class="main-button cancel-button">Cancelar</button>
        </div>
    </div>


    <div id="tutorial-screen">
        <h2>Como Jogar</h2>
        <div class="section">
            <h3><svg class="icon icon-small" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 6h2v8h-2zm0 9h2v2h-2z"/></svg>Movimento e Mira</h3>
            <ul>
                <li><strong>W / A / S / D:</strong> Mover a nave.</li>
                <li>Mire com o **Mouse** para onde a nave deve apontar.</li>
                <li>**SHIFT:** Segure para um movimento mais lento e preciso.</li>
                <li>**Dispositivos Móveis:** Use o **Joystick Virtual** no lado esquerdo da tela para mover, e **toque e segure em qualquer lugar na metade direita da tela** para atirar e mirar automaticamente no inimigo mais próximo.</li>
            </ul>
        </div>
        <div class="section">
            <h3><svg class="icon icon-small" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 6h2v8h-2zm0 9h2v2h-2z"/></svg>Atirar</h3>
            <ul>
                <li><strong>Botão Esquerdo do Mouse (ou Toque e Segure na metade direita da tela no Celular):</strong> Atira projéteis padrão.</li>
                <li><strong>Power-ups:</strong>
                    <ul>
                        <li><svg class="icon icon-small pickup-icon-rapidfire"><use xlink:href="#icon-rapidfire"></use></svg><strong>Tiro Rápido (F):</strong> Aumenta a velocidade de disparo por um tempo.</li>
                        <li><svg class="icon icon-small pickup-icon-tripleshot"><use xlink:href="#icon-tripleshot"></use></svg><strong>Tiro Triplo (T):</strong> Dispara 3 projéteis de uma vez por um tempo.</li>
                    </ul>
                </li>
            </ul>
        </div>
        <div class="section">
            <h3><svg class="icon icon-small" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 6h2v8h-2zm0 9h2v2h-2z"/></svg>Habilidades e Coletas</h3>
            <ul>
                <li><svg class="icon icon-small pickup-icon-shield"><use xlink:href="#icon-shield"></use></svg><strong>Q (Escudo) / Botão na Tela:</strong> Ativa um escudo temporário de <strong>20 segundos</strong> que te protege de danos. Tem um tempo de recarga. Pode ser coletado como item.</li>
                <li><svg class="icon icon-small pickup-icon-drone"><use xlink:href="#icon-drone"></use></svg><strong>F (Drone de Combate) / Botão na Tela:</strong> Invoca um drone de combate que ataca inimigos automaticamente. Acumule <strong>100 pontos de drone</strong> (coletando itens ou destruindo inimigos) para ativá-lo. Você pode ter múltiplos drones (até 5). Drones têm HP e podem ser destruídos.</li>
                <li><svg class="icon icon-small pickup-icon-missile"><use xlink:href="#icon-missile"></use></svg><strong>G (Míssil Hacker) / Botão na Tela:</strong> Lança um míssil que persegue o inimigo mais próximo. Ele explode ao atingir o primeiro inimigo, causando dano massivo em área (dano reduzido contra chefões e elites). Você começa com <strong>2 mísseis</strong>, e cada um tem um tempo de recarga de <strong>50 segundos</strong>. Pode ser coletado como item para reduzir o tempo de recarga de um míssil ou adicionar um novo.</li>
                <li><svg class="icon icon-small pickup-icon-bomb"><use xlink:href="#icon-bomb"></use></svg><strong>Scroll do Mouse (Bomba) / Botão na Tela:</strong> Ativa uma bomba que destrói todos os inimigos e projéteis inimigos na tela. Carregada a cada <strong>10 segundos</strong> e acumulável até <strong>20</strong>.</li>
                <li><svg class="icon icon-small menu-icon-dash"><use xlink:href="#icon-energy"></use></svg><strong>E (Impulso / Dash) / Botão na Tela:</strong> Realiza um rápido impulso na direção do movimento, te tornando invulnerável por um curto período. Consome <strong>Energia</strong>.</li>
                <li><svg class="icon icon-small menu-icon-defense-drone"><use xlink:href="#icon-defense-drone"></use></svg><strong>C (Drone de Defesa) / Botão na Tela:</strong> Invoca um drone de defesa que protege o jogador de tiros inimigos. Cada drone tem <strong>800 HP</strong>. Custa <strong>80 pontos de drone</strong> e você pode ter até 5.</li>
                <li><svg class="icon icon-small menu-icon-predator"><use xlink:href="#icon-score"></use></svg><strong>Botão Direito do Mouse (Predador) / Botão na Tela:</strong> Ativa um disparo em leque com 5 tiros. Dura <strong>30 segundos</strong> e tem um tempo de recarga de <strong>40 segundos</strong>.</li>
                <li><svg class="icon menu-icon-multiplier"><use xlink:href="#icon-multiplier"></use></svg><strong>T (Multiplicador de Pontuação) / Botão na Tela:</strong> Ativa um multiplicador de <strong>10x</strong> em todos os pontos por <strong>10 segundos</strong>.</li>
                 <li><svg class="icon menu-icon-drone"><use xlink:href="#icon-drone"></use></svg><strong>V (HEAD SHOT):</strong> Invoca 30 drones de ataque temporários. Desbloqueado com 100.000 pontos.</li>
            </ul>
        </div>
        <button id="back-to-main-button" class="back-button">Voltar ao Menu Principal</button>
    </div>

    <div id="game-over-screen">
        <h2>FIM DE JOGO!</h2>
        <p>Pontuação Final: <span id="final-score">0</span></p>
        <div class="button-group">
            <button id="restart-game-button" class="main-button">Reiniciar</button>
            <button id="back-to-main-from-gameover-button" class="main-button">Menu Principal</button>
        </div>
    </div>

    <div id="bottom-bar-menu">
        <div class="menu-item" id="score-item">
            <svg class="icon menu-icon-score"><use xlink:href="#icon-score"></use></svg>
            <span class="label">PTS</span>
            <span id="score">0</span>
        </div>
        <div class="menu-item" id="wave-item">
            <svg class="icon menu-icon-wave"><use xlink:href="#icon-wave"></use></svg>
            <span class="label">ONDA</span>
            <span id="wave-number">1</span>
        </div>
        <div class="menu-item" id="lives-item">
            <svg class="icon menu-icon-lives"><use xlink:href="#icon-life"></use></svg>
            <span class="label">VIDAS</span>
            <span id="lives">5</span>
        </div>
        <div class="menu-item" id="shield-item">
            <svg class="icon menu-icon-shield"><use xlink:href="#icon-shield"></use></svg>
            <span class="label">ESC (Q)</span>
            <span id="shield-status-text" class="not-ready"></span>
        </div>
        <div class="menu-item" id="energy-item">
            <svg class="icon menu-icon-energy"><use xlink:href="#icon-energy"></use></svg>
            <span class="label">ENERGIA</span>
            <span id="energy-status-text">100%</span>
        </div>
        <div class="menu-item" id="drone-combat-item">
            <svg class="icon menu-icon-drone-points"><use xlink:href="#icon-drone"></use></svg>
            <span class="label">DRONE C (F)</span>
            <span id="drone-points-text">0/100</span>
        </div>
        <div class="menu-item" id="drone-defense-item">
            <svg class="icon menu-icon-defense-drone"><use xlink:href="#icon-defense-drone"></use></svg>
            <span class="label">DRONE D (C)</span>
            <span id="defense-drone-count-text">0/5</span>
        </div>
        <div class="menu-item" id="missile-item">
            <svg class="icon menu-icon-missile"><use xlink:href="#icon-missile"></use></svg>
            <span class="label">MÍSSIL (G)</span>
            <span id="missile-slots-text"></span>
        </div>
        <div class="menu-item" id="dash-item">
            <svg class="icon menu-icon-dash"><use xlink:href="#icon-energy"></use></svg>
            <span class="label">IMPULSO (E)</span>
            <span id="dash-ability-text" class="not-ready"></span>
        </div>
        <div class="menu-item" id="bomb-item">
            <svg class="icon menu-icon-bomb"><use xlink:href="#icon-bomb"></use></svg>
            <span class="label">BOMBA (S)</span>
            <span id="bomb-ability-text" class="not-ready"></span>
        </div>
        <div class="menu-item" id="rapidfire-item">
            <svg class="icon menu-icon-rapidfire"><use xlink:href="#icon-rapidfire"></use></svg>
            <span class="label">TIRO R</span>
            <span id="rapidfire-status-text" class="not-ready"></span>
        </div>
        <div class="menu-item" id="tripleshot-item">
            <svg class="icon menu-icon-tripleshot"><use xlink:href="#icon-tripleshot"></use></svg>
            <span class="label">TIRO T</span>
            <span id="tripleshot-status-text" class="not-ready"></span>
        </div>
        <div class="menu-item" id="predator-item">
            <svg class="icon menu-icon-predator"><use xlink:href="#icon-score"></use></svg>
            <span class="label">PREDADOR (D)</span>
            <span id="predator-status-text" class="not-ready"></span>
        </div>
        <div class="menu-item" id="score-multi-item">
            <svg class="icon menu-icon-multiplier"><use xlink:href="#icon-multiplier"></use></svg>
            <span class="label">MULTI (T)</span>
            <span id="score-multiplier-status-text" class="not-ready"></span>
        </div>
        <div class="menu-item" id="headshot-item" style="display: none;">
            <svg class="icon menu-icon-drone"><use xlink:href="#icon-drone"></use></svg>
            <span class="label">HEADSHOT (V)</span>
            <span id="headshot-status-text" class="not-ready"></span>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="reticle"></div>

    <div id="mobile-controls">
        <div id="joystick-area">
            <div id="joystick-inner"></div>
        </div>
        <div id="tap-to-fire-area"></div>
        
        <div id="ability-buttons-container">
            <div class="ability-button" id="btn-shield">
                <svg><use xlink:href="#icon-shield"></use></svg> ESC
            </div>
            <div class="ability-button" id="btn-dash">
                <svg><use xlink:href="#icon-energy"></use></svg> IMP
            </div>
            <div class="ability-button" id="btn-combat-drone">
                <svg><use xlink:href="#icon-drone"></use></svg> DC
            </div>
            <div class="ability-button" id="btn-missile">
                <svg><use xlink:href="#icon-missile"></use></svg> MIS
            </div>
            <div class="ability-button" id="btn-defense-drone">
                <svg><use xlink:href="#icon-defense-drone"></use></svg> DD
            </div>
            <div class="ability-button" id="btn-multiplier">
                <svg><use xlink:href="#icon-multiplier"></use></svg> MULT
            </div>
            <div class="ability-button" id="btn-predator">
                <svg><use xlink:href="#icon-score"></use></svg> PRED
            </div>
            <div class="ability-button" id="btn-bomb">
                <svg><use xlink:href="#icon-bomb"></use></svg> BOM
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const body = document.body;

        // References to UI elements
        const mainScreen = document.getElementById('main-screen');
        const tutorialScreen = document.getElementById('tutorial-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const playNormalPcButton = document.getElementById('play-normal-pc-button');
        const playNormalMobileButton = document.getElementById('play-normal-mobile-button');
        const challengeButton = document.getElementById('challenge-button');
        const challengeModal = document.getElementById('challenge-modal');
        const confirmChallengePcButton = document.getElementById('confirm-challenge-pc-button');
        const confirmChallengeMobileButton = document.getElementById('confirm-challenge-mobile-button');
        const cancelChallengeButton = document.getElementById('cancel-challenge-button');
        const tutorialButton = document.getElementById('tutorial-button');
        const backToMainButton = document.getElementById('back-to-main-button');
        const restartGameButton = document.getElementById('restart-game-button');
        const backToMainFromGameoverButton = document.getElementById('back-to-main-from-gameover-button');
        const playerNameInput = document.getElementById('player-name-input');
        const highScoresBody = document.getElementById('high-scores-body');
        const finalScoreDisplay = document.getElementById('final-score');
        const svgIconsContainer = document.getElementById('svg-icons');
        const orientationMessage = document.getElementById('orientation-message');

        // New Bottom Bar Menu references
        const bottomBarMenu = document.getElementById('bottom-bar-menu');
        const scoreDisplay = document.getElementById('score');
        const waveDisplay = document.getElementById('wave-number');
        const livesDisplay = document.getElementById('lives');
        const shieldStatusText = document.getElementById('shield-status-text');
        const energyStatusText = document.getElementById('energy-status-text');
        const dronePointsText = document.getElementById('drone-points-text');
        const missileSlotsText = document.getElementById('missile-slots-text');
        const dashAbilityText = document.getElementById('dash-ability-text');
        const bombAbilityText = document.getElementById('bomb-ability-text');
        const defenseDroneCountText = document.getElementById('defense-drone-count-text');
        const rapidfireStatusText = document.getElementById('rapidfire-status-text');
        const tripleshotStatusText = document.getElementById('tripleshot-status-text');
        const predatorStatusText = document.getElementById('predator-status-text');
        const scoreMultiplierStatusText = document.getElementById('score-multiplier-status-text'); 
        const headshotStatusText = document.getElementById('headshot-status-text');

        // Menu item references for status classes
        const shieldItem = document.getElementById('shield-item');
        const energyItem = document.getElementById('energy-item');
        const droneCombatItem = document.getElementById('drone-combat-item');
        const droneDefenseItem = document.getElementById('drone-defense-item');
        const missileItem = document.getElementById('missile-item');
        const dashItem = document.getElementById('dash-item');
        const bombItem = document.getElementById('bomb-item');
        const rapidfireItem = document.getElementById('rapidfire-item');
        const tripleshotItem = document.getElementById('tripleshot-item');
        const predatorItem = document.getElementById('predator-item');
        const scoreMultiItem = document.getElementById('score-multi-item');
        const headshotItem = document.getElementById('headshot-item');

        const reticle = document.getElementById('reticle');

        // Mobile Controls Elements (will be hidden on desktop, but referenced)
        const mobileControls = document.getElementById('mobile-controls');
        const joystickArea = document.getElementById('joystick-area'); // Left Joystick
        const joystickInner = document.getElementById('joystick-inner');
        const tapToFireArea = document.getElementById('tap-to-fire-area'); // New touch-to-fire area
        const abilityButtonsContainer = document.getElementById('ability-buttons-container');
        const btnShield = document.getElementById('btn-shield');
        const btnDash = document.getElementById('btn-dash'); 
        const btnCombatDrone = document.getElementById('btn-combat-drone');
        const btnMissile = document.getElementById('btn-missile');
        const btnDefenseDrone = document.getElementById('btn-defense-drone');
        const btnMultiplier = document.getElementById('btn-multiplier');
        const btnPredator = document.getElementById('btn-predator');
        const btnBomb = document.getElementById('btn-bomb');


        // --- Global Game Variables ---
        let player = null;
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let particles = [];
        let thrustParticles = [];
        let spaceParticles = [];
        let stars = [];
        let drones = []; // Player combat drones
        let temporaryDrones = [];
        let defenseDrones = []; // Player defense drones
        let specialDrone = null; // Boss special drone
        let bossDrones = []; // Boss attack drones
        let bossBombs = []; // NEW: For Hunter bombs
        let pickups = [];
        let bombFragments = [];
        let score = 0;
        let lives = 3;
        let gameOver = false;
        let mouseIsDown = false; // Used only for desktop firing
        let tapToFireActive = false; // Variable for active touch-to-fire state (mobile)
        let tapToFireTargetX = 0; // X-coordinate of touch for aiming/firing
        let tapToFireTargetY = 0; // Y-coordinate of touch for aiming/firing

        let droneCharge = 0;
        let animationFrameId = null;
        let lastFrameTime = performance.now();
        let playerName = "Player"; 
        let currentWave = 1;
        let pointsForNextLife = 2000;
        let maxLives = 90;

        let bombCount = 0; 
        const BOMB_CHARGE_INTERVAL = 10000; // 10 seconds
        let lastBombChargeTime = 0; 
        const MAX_BOMBS = 20;

        // Score Multiplier variables
        let scoreMultiplierActive = false; 
        let scoreMultiplierTimer = 0; 
        let lastScoreMultiplierActivation = -Infinity;
        const SCORE_MULTIPLIER_DURATION = 10000; // 10 seconds
        const GAME_SCORE_MULTIPLIER_AMOUNT = 50; // Multiplies by 50
        const SCORE_MULTIPLIER_COOLDOWN = 30000; // 30 seconds cooldown
        
        // Head Shot ability variables
        let headShotAvailable = false;
        let headShotActive = false;
        let headShotTimer = 0;
        let lastHeadShotActivation = -Infinity;
        let headShotCooldown = 40000; // 40 seconds initial cooldown
        const HEAD_SHOT_DURATION = 15000; // 15 seconds
        const HEAD_SHOT_COOLDOWN_INCREASE = 1.2; // 20% increase


        let nextBossSpawnScore = 1000; 
        let nextMegaBossSpawnScore = 10000;
        let nextHunterSpawnScore = 20000;
        let nextArtillerySpawnScore = 30000;
        let nextSkullOverlordSpawnScore = 100000;

        const PLAYER_BULLET_DAMAGE = 50;
        const PLAYER_BULLET_DAMAGE_BOSS_COMMON = 0.002; // 0.2% of max HP

        // Player configurations
        const PLAYER_SIZE = 45; 
        const PLAYER_BASE_SPEED = 300; // units per second
        const PLAYER_SLOW_SPEED_FACTOR = 0.5; 
        let playerSpeed = PLAYER_BASE_SPEED; 
        const PLAYER_BULLET_SPEED = 500; // units per second
        const PLAYER_BASE_BULLET_COOLDOWN = 100;
        let playerBulletCooldown = PLAYER_BASE_BULLET_COOLDOWN; 
        let lastPlayerShotTime = 0;
        const BULLET_TRAIL_LENGTH = 3;
        const PLAYER_TURN_SPEED = Math.PI * 6; // Radians per second
        let playerInvulnerable = false; 
        let playerInvulnerableTimer = 0;
        let playerFlashTimer = 0;
        const PLAYER_FLASH_DURATION = 1000;
        const PLAYER_MISSILE_HACKER_EXPLOSION_DAMAGE = 200;

        // Player debuffs
        let playerBulletCooldownSlowed = false;
        let playerBulletCooldownSlowedTimer = 0;
        const PLAYER_SLOW_BULLET_DURATION = 5000; 
        const PLAYER_SLOW_BULLET_FACTOR = 2;

        // Shield configurations
        const SHIELD_DURATION = 20000; 
        const SHIELD_COOLDOWN = 20000;
        const COLLECTED_SHIELD_DURATION = 20000;
        let shieldActive = false;
        let shieldTimer = 0;
        let lastShieldActivation = -SHIELD_COOLDOWN;

        // Energy configurations (Dash)
        const MAX_ENERGY = 100;
        const DASH_COST = 25;
        const ENERGY_REGEN_RATE = 10; // units per second
        const DASH_DURATION = 200; 
        let currentEnergy = MAX_ENERGY;
        let lastEnergyRegenTime = performance.now();

        // Hacker missile configurations
        const MAX_MISSILES = 20; 
        const MISSILE_COOLDOWN_PER_SLOT = 50000; 
        const MISSILE_COUNT_HACKER = 1; 
        const MISSILE_HACKER_SPEED = 600; // units per second
        let missileSlots = []; 
        const EXPLOSION_RADIUS = 80;
        const ELITE_BOSS_EXPLOSION_DAMAGE_MULTIPLIER = 0.1; 

        // Bomb configurations (clear map)
        const BOMB_EXPLOSION_PARTICLE_COUNT = 30;
        const BOMB_EXPLOSION_RADIUS_MAX = 400; 

        // Predator ability configurations
        const PREDATOR_DURATION = 30000; 
        const PREDATOR_COOLDOWN = 40000; 
        const PREDATOR_BULLET_COUNT = 5;
        const PREDATOR_BULLET_SPREAD = Math.PI / 4; 
        let predatorActive = false;
        let predatorTimer = 0;
        let lastPredatorActivation = -PREDATOR_COOLDOWN; 

        // Enemy configurations
        const ENEMY_SPAWN_INTERVAL_BASE = 900;
        let lastEnemySpawnTime = 0;
        const ENEMY_BULLET_SPEED = 250; // units per second
        const ENEMY_BULLET_COOLDOWN_MIN = 700;
        const ENEMY_BULLET_COOLDOWN_MAX = 2000;
        const ENEMY_ELITE_MISSILE_DAMAGE_MIN = 0.01; 
        const ENEMY_ELITE_MISSILE_DAMAGE_MAX = 0.05; 

        let bossActive = false; // Indicates if any boss is on screen
        let megaBossWaveActive = false; // Indicates if the mega boss wave is active
        let hunterWaveActive = false; // NEW: Hunter Wave flag

        // Enemy types and their base properties
        const ENEMY_BASE_TYPES = {
            'standard': {
                size: 30, speed: { min: 60, max: 180 }, hp: 50, score: 10, droneCharge: 10,
                color: '#FF4500', detailColor: '#FFA500', shootMultiple: 1, bulletColor: '#FF6600', isBoss: false, isElite: false,
                bulletCooldownMin: 700, bulletCooldownMax: 2000, explosionDamage: 0
            },
            'chaser': {
                size: 25, speed: { min: 120, max: 240 }, hp: 60, score: 15, droneCharge: 15,
                color: '#32CD32', detailColor: '#ADFF2F', shootMultiple: 1, bulletColor: '#99FF99', isBoss: false, isElite: false,
                bulletCooldownMin: 600, bulletCooldownMax: 1800, explosionDamage: 0
            },
            'tank': {
                size: 40, speed: { min: 40, max: 100 }, hp: 150, score: 25, droneCharge: 25,
                color: '#4169E1', detailColor: '#6495ED', shootMultiple: 1, bulletColor: '#ADD8E6', isBoss: false, isElite: false,
                bulletCooldownMin: 900, bulletCooldownMax: 2500, explosionDamage: 0
            },
            'multi-shooter': {
                size: 35, speed: { min: 80, max: 160 }, hp: 80, score: 20, droneCharge: 20,
                color: '#8A2BE2', detailColor: '#BA55D3', shootMultiple: 3, bulletColor: '#FF99FF', isBoss: false, isElite: false,
                bulletCooldownMin: 800, bulletCooldownMax: 2200, explosionDamage: 0
            },
            'elite': { 
                size: 35, speed: { min: 120, max: 280 }, hp: 120, score: 30, droneCharge: 30,
                color: '#00FFFF', detailColor: '#00BFFF', shootMultiple: 1, bulletColor: '#FFFF66', isBoss: false, isElite: true,
                bulletCooldownMin: 1500, bulletCooldownMax: 3000, 
                hasMissile: true, missileDamageMin: ENEMY_ELITE_MISSILE_DAMAGE_MIN, missileDamageMax: ENEMY_ELITE_MISSILE_DAMAGE_MAX,
                accelerationChance: 0.005, 
                accelerationDuration: 1000,
                hpMultiplierPerWave: 2, 
                speedMultiplierPerWave: 2, 
                maxOnScreenMultiplierPerWave: 2,
                explosionDamage: 0
            },
            'boss': {
                size: 70, speed: { min: 40, max: 80 }, hp: 15000, score: 500, droneCharge: 100,
                color: '#FFD700', detailColor: '#FFFF00', shootMultiple: 8, bulletColor: '#FF0000', isBoss: true, isElite: false,
                bulletSpeed: 280, 
                bulletCooldownMin: 300, bulletCooldownMax: 800,
                maxBossDrones: 3, bossDroneSpawnCooldown: 10000,
                explosionDamage: 0, missileDamageMultiplier: 0.20 // Takes 20% damage from missiles
            },
            'hunter': { // NEW BOSS
                size: 150, speed: { min: 50, max: 80 }, hp: 200000, score: 10000, droneCharge: 1000,
                color: '#B80000', detailColor: '#FF1111', isBoss: true, isElite: true, shootMultiple: 0,
                launchesBombs: true, bombLaunchCooldown: 1500,
                explosionDamage: 0, missileDamageMultiplier: 0.05,
            },
            'hunter_minion': { // NEW MINION
                size: 25, speed: { min: 150, max: 250 }, hp: 100, score: 20, droneCharge: 5,
                color: '#CC0000', detailColor: '#FF6666', shootMultiple: 1, bulletColor: '#FF8888', isBoss: false, isElite: true,
                bulletSpeed: 400, bulletCooldownMin: 1200, bulletCooldownMax: 2500,
                isHoming: true,
            },
             'artillery_alien': { // NEW BOSS
                size: 120, speed: { min: 0, max: 0 }, hp: 100000, score: 10000, droneCharge: 500,
                color: '#4C0099', detailColor: '#9370DB', isBoss: true, isElite: true,
                shootMultiple: 5, bulletCooldownMin: 1000, bulletCooldownMax: 2000,
                launchesBombs: true, bombLaunchCooldown: 2500,
                firesHomingMissiles: true, missileLaunchCooldown: 5000,
            },
            'skull_overlord': {
                size: 200, speed: { min: 30, max: 60 }, hp: 500000, score: 25000, droneCharge: 2000,
                color: '#228B22', detailColor: '#00FF00', isBoss: true, isElite: true, shootMultiple: 0,
                shootsLaser: true, laserChargeTime: 3000, laserFireTime: 1000, laserCooldown: 5000,
                explosionDamage: 0
            },
            'skull_minion': {
                size: 30, speed: {min: 100, max: 200}, hp: 200, score: 50, droneCharge: 10,
                color: '#556B2F', detailColor: '#6B8E23', shootMultiple: 1, bulletColor: '#9ACD32', isBoss: false, isElite: true,
                bulletSpeed: 350, bulletCooldownMin: 1000, bulletCooldownMax: 2000, isHoming: true
            },
            'disruptor': {
                size: 20, speed: { min: 160, max: 280 }, hp: 40, score: 18, droneCharge: 18,
                color: '#FF69B4', detailColor: '#FFB6C1', shootMultiple: 1, bulletColor: '#FFFF00', isBoss: false, isElite: false,
                bulletCooldownMin: 1000, bulletCooldownMax: 2500, isDebuffBullet: true, explosionDamage: 0
            },
            'heavy_shooter': {
                size: 45, speed: { min: 40, max: 100 }, hp: 180, score: 28, droneCharge: 28,
                color: '#556B2F', detailColor: '#8FBC8F', shootMultiple: 3, bulletColor: '#FF0000', isBoss: false, isElite: false,
                bulletCooldownMin: 1500, bulletCooldownMax: 3000, explosiveBullets: true, explosionDamage: 0
            },
            'exploder': {
                size: 35, speed: { min: 200, max: 360 }, hp: 70, score: 22, droneCharge: 22,
                color: '#FFD700', detailColor: '#FFCC00', shootMultiple: 0, bulletColor: '', isBoss: false, isElite: false, 
                explosionDamage: 2, 
                bulletCooldownMin: 0, bulletCooldownMax: 0 
            },
            'armored': {
                size: 40, speed: { min: 30, max: 80 }, hp: 250, score: 35, droneCharge: 35,
                color: '#696969', detailColor: '#A9A9A9', shootMultiple: 1, bulletColor: '#D3D3D3', isBoss: false, isElite: false,
                bulletCooldownMin: 1200, bulletCooldownMax: 2800, explosionDamage: 0
            }
        };

        // Wave configurations - Multiplied by 5
        const WAVE_CONFIG = {
            1: { spawnRate: 900, enemies: ['standard'], maxOnScreen: 200, speedMultiplier: 1, hpMultiplier: 1, eliteMaxOnScreen: 0 },
            2: { spawnRate: 850, enemies: ['standard', 'chaser', 'elite'], maxOnScreen: 250, speedMultiplier: 1.05, hpMultiplier: 1.1, eliteMaxOnScreen: 5 }, 
            3: { spawnRate: 800, enemies: ['standard', 'chaser', 'tank', 'elite', 'disruptor'], maxOnScreen: 300, speedMultiplier: 1.1, hpMultiplier: 1.2, eliteMaxOnScreen: 10 }, 
            4: { spawnRate: 750, enemies: ['standard', 'chaser', 'tank', 'multi-shooter', 'elite', 'disruptor', 'heavy_shooter'], maxOnScreen: 350, speedMultiplier: 1.15, hpMultiplier: 1.3, eliteMaxOnScreen: 20 },
            5: { spawnRate: 700, enemies: ['chaser', 'tank', 'multi-shooter', 'elite', 'disruptor', 'heavy_shooter', 'exploder'], maxOnScreen: 400, speedMultiplier: 1.2, hpMultiplier: 1.4, eliteMaxOnScreen: 40 },
            6: { spawnRate: 650, enemies: ['tank', 'multi-shooter', 'elite', 'disruptor', 'heavy_shooter', 'exploder', 'armored'], maxOnScreen: 450, speedMultiplier: 1.25, hpMultiplier: 1.5, eliteMaxOnScreen: 50 },
            default: { spawnRate: 600, enemies: Object.keys(ENEMY_BASE_TYPES).filter(type => !ENEMY_BASE_TYPES[type].isBoss), maxOnScreen: 500, speedMultiplier: 1.3, hpMultiplier: 1.6, eliteMaxOnScreen: 60 }
        };

        // Star configurations
        const NUM_STARS = 150;
        const STAR_SPEED_MIN = 10; 
        const STAR_SPEED_MAX = 50; 
        const STAR_COLOR_VARIATIONS = ['#FFFFFF', '#E0E0E0', '#D0D0FF', '#FFFFA0']; 

        // Background Particle (Space) configurations
        const NUM_SPACE_PARTICLES = 100;
        const SPACE_PARTICLE_SPEED_MIN = 30; 
        const SPACE_PARTICLE_SPEED_MAX = 120; 
        const SPACE_PARTICLE_RADIUS_MIN = 0.8;
        const SPACE_PARTICLE_RADIUS_MAX = 1.5; 

        // Thrust Particle (Player Ship) configurations
        const THRUST_PARTICLE_COUNT_PER_FRAME = 1; 
        const THRUST_PARTICLE_MAX_SPEED = 200;
        const THRUST_PARTICLE_MIN_RADIUS = 1; 
        const THRUST_PARTICLE_MAX_RADIUS = 2; 
        const THRUST_PARTICLE_LIFE = 0.4;
        const THRUST_PARTICLE_DECAY = 0.08;
        const THRUST_PARTICLE_GRAVITY_FACTOR = 0.05; 

        // Combat Drone (player controlled) configurations
        const DRONE_SIZE = 25; 
        const DRONE_BULLET_SPEED = 400; 
        const DRONE_BULLET_COOLDOWN = 300;
        let DRONE_MAX_DRONES = 5;
        const DRONE_HP = 340;
        const DRONE_ACTIVATION_COST = 100;
        const DRONE_OFFSETS = [
            { x: -50, y: 0 }, 
            { x: 50, y: 0 },
            { x: -35, y: -35 }, 
            { x: 35, y: -35 },
            { x: 0, y: 45 } 
        ];

        // Defense Drone configurations
        const DEFENSE_DRONE_SIZE = 28; 
        const DEFENSE_DRONE_HP = 1200;
        const DEFENSE_DRONE_COST = 80;
        const DEFENSE_DRONE_MAX = 5;
        const DEFENSE_DRONE_RADIUS = 60; 
        const DEFENSE_DRONE_ORBIT_SPEED = Math.PI * 0.1; 

        // Special Drone (boss controlled) configurations
        const SPECIAL_DRONE_SIZE = 30; 
        const SPECIAL_DRONE_BULLET_SPEED = 480; 
        const SPECIAL_DRONE_BULLET_COOLDOWN = 2000; 
        const SPECIAL_DRONE_HP = 1500; 
        const SPECIAL_DRONE_BULLET_EXPLOSION_RADIUS = 20; 
        const SPECIAL_DRONE_BULLET_DAMAGE = 20; 
        const SPECIAL_DRONE_OFFSETS = [ 
            { x: -70, y: 70 }, 
            { x: 70, y: 70 }
        ];

        // Boss Drone configurations
        const BOSS_DRONE_SIZE = 20; 
        const BOSS_DRONE_HP = 100;
        const BOSS_DRONE_SPEED = 160; 
        const BOSS_DRONE_BULLET_COOLDOWN = 1500;
        const BOSS_DRONE_BULLET_SPEED = 280; 


        // Drop configurations - slightly increased frequency
        const DROP_CHANCE = {
            'life': 0.02,
            'shield': 0.02,
            'drone': 0.015,
            'missile': 0.02,
            'rapidfire': 0.025,
            'tripleshot': 0.025
        };

        // Temporary power-ups
        let rapidFireActive = false;
        let rapidFireTimer = 0;
        const RAPID_FIRE_DURATION = 5000;
        const RAPID_FIRE_COOLDOWN_FACTOR = 0.4; 

        let tripleShotActive = false;
        let tripleShotTimer = 0;
        const TRIPLE_SHOT_DURATION = 5000;

        // Player inputs (keys pressed)
        const keys = {
            w: false, a: false, s: false, d: false, q: false, e: false, f: false, g: false, c: false, shift: false, t: false, v: false
        };

        // Player aim (Mouse/Touch)
        let mouseX = 0; // Used for desktop aiming
        let mouseY = 0; // Used for desktop aiming

        // Virtual Joystick Variables (Left Joystick - Movement)
        let joystickActive = false;
        let joystickCenterX = 0;
        let joystickCenterY = 0;
        const JOYSTICK_MAX_DIST = 35; 
        const JOYSTICK_DEADZONE = 8; 
        let joystickDeltaX = 0;
        let joystickDeltaY = 0;

        // Control mode variable
        let controlMode = null; // 'pc' or 'mobile'
        let isChallengeMode = false;
        let nextDroneUpgradeScore = 5000;

        // --- Helper Functions and Classes ---

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            if (player) {
                player.resetPosition();
            }
            // Reset mouse/aim position to center initially
            mouseX = canvas.width / 2;
            mouseY = canvas.height / 2;

            stars = [];
            initStars();
            spaceParticles = [];
            initSpaceParticles();
        }

        // Function to check orientation and manage overall visibility
        function checkOrientation() {
            if (controlMode === 'mobile' && window.innerHeight > window.innerWidth) { // Portrait mode AND mobile control mode selected
                orientationMessage.style.display = 'flex';
                // Force hide all game/menu elements using !important
                mainScreen.style.display = 'none';
                tutorialScreen.style.display = 'none';
                gameOverScreen.style.display = 'none';
                canvas.style.display = 'none';
                bottomBarMenu.style.display = 'none';
                reticle.style.display = 'none';
                mobileControls.style.display = 'none'; 

                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null; // Stop game loop if active
                }
                return true; // Indicate that portrait mode is active and elements are hidden
            } else { // Landscape mode or PC control mode selected
                orientationMessage.style.display = 'none';
                return false; // Indicate normal orientation or PC mode
            }
        }


        class Particle {
            constructor(x, y, vx, vy, radius, color, life, decayRate = 0.02, gravityY = 0) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.radius = radius;
                this.color = color;
                // Life is now in seconds, so decay rate is per second
                this.life = life; 
                this.opacity = 1;
                this.decayRate = decayRate; // % per second
                this.gravityY = gravityY;
                this.initialRadius = radius;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.opacity);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += (this.vy + this.gravityY) * deltaTime;
                this.life -= deltaTime; // Decay life by delta time
                this.opacity -= this.decayRate * deltaTime; // Decay opacity by delta time
                this.radius = this.initialRadius * (this.life / (this.life + (1 / this.decayRate)));
                if (this.radius < 0) this.radius = 0;
            }
        }

        class Star {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.radius = Math.random() * 1.0 + 0.5; 
                this.speed = Math.random() * (STAR_SPEED_MAX - STAR_SPEED_MIN) + STAR_SPEED_MIN;
                this.opacity = Math.random() * 0.8 + 0.2;
                this.color = STAR_COLOR_VARIATIONS[Math.floor(Math.random() * STAR_COLOR_VARIATIONS.length)];
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            update(deltaTime) {
                this.y += this.speed * deltaTime;
                if (this.y > canvas.height + this.radius) {
                    this.x = Math.random() * canvas.width;
                    this.y = -this.radius;
                    this.radius = Math.random() * 1.0 + 0.5;
                    this.speed = Math.random() * (STAR_SPEED_MAX - STAR_SPEED_MIN) + STAR_SPEED_MIN;
                    this.opacity = Math.random() * 0.8 + 0.2;
                    this.color = STAR_COLOR_VARIATIONS[Math.floor(Math.random() * STAR_COLOR_VARIATIONS.length)];
                }
            }
        }

        class SpaceParticle {
            constructor() {
                const edge = Math.floor(Math.random() * 4);
                if (edge === 0) {
                    this.x = Math.random() * canvas.width;
                    this.y = -SPACE_PARTICLE_RADIUS_MAX;
                } else if (edge === 1) {
                    this.x = canvas.width + SPACE_PARTICLE_RADIUS_MAX;
                    this.y = Math.random() * canvas.height;
                } else if (edge === 2) {
                    this.x = Math.random() * canvas.width;
                    this.y = canvas.height + SPACE_PARTICLE_RADIUS_MAX;
                } else {
                    this.x = -SPACE_PARTICLE_RADIUS_MAX;
                    this.y = Math.random() * canvas.height;
                }

                this.radius = Math.random() * (SPACE_PARTICLE_RADIUS_MAX - SPACE_PARTICLE_RADIUS_MIN) + SPACE_PARTICLE_RADIUS_MIN;
                this.speed = Math.random() * (SPACE_PARTICLE_SPEED_MAX - SPACE_PARTICLE_SPEED_MIN) + SPACE_PARTICLE_SPEED_MIN;
                this.opacity = Math.random() * 0.8 + 0.2;
                this.color = `rgba(255, 255, 255, ${this.opacity})`;

                const targetX = canvas.width / 2;
                const targetY = canvas.height / 2;
                const angleToCenter = Math.atan2(targetY - this.y, targetX - this.x);
                this.vx = Math.cos(angleToCenter) * this.speed * 0.5;
                this.vy = Math.sin(angleToCenter) * this.speed * 0.5;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            update(deltaTime) {
                // Background particles should move relative to player's simulated movement
                const backgroundMovementScale = 0.05; 
                // Move background only if player is actively moving, not just joystick active
                if ((controlMode === 'mobile' && Math.hypot(joystickDeltaX, joystickDeltaY) > JOYSTICK_DEADZONE) || (controlMode === 'pc' && (keys.w || keys.s || keys.a || keys.d))) {
                    if ((controlMode === 'mobile' && joystickDeltaY < 0) || (controlMode === 'pc' && keys.w)) this.y += playerSpeed * backgroundMovementScale * deltaTime;
                    if ((controlMode === 'mobile' && joystickDeltaY > 0) || (controlMode === 'pc' && keys.s)) this.y -= playerSpeed * backgroundMovementScale * deltaTime;
                    if ((controlMode === 'mobile' && joystickDeltaX < 0) || (controlMode === 'pc' && keys.a)) this.x += playerSpeed * backgroundMovementScale * deltaTime;
                    if ((controlMode === 'mobile' && joystickDeltaX > 0) || (controlMode === 'pc' && keys.d)) this.x -= playerSpeed * backgroundMovementScale * deltaTime;
                }
                
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;

                if (this.x < -this.radius || this.x > canvas.width + this.radius ||
                    this.y < -this.radius || this.y > canvas.height + this.radius) {
                    this.reset();
                }
            }

            reset() {
                const edge = Math.floor(Math.random() * 4);
                if (edge === 0) {
                    this.x = Math.random() * canvas.width;
                    this.y = -SPACE_PARTICLE_RADIUS_MAX;
                } else if (edge === 1) {
                    this.x = canvas.width + SPACE_PARTICLE_RADIUS_MAX;
                    this.y = Math.random() * canvas.height;
                } else if (edge === 2) {
                    this.x = Math.random() * canvas.width;
                    this.y = canvas.height + SPACE_PARTICLE_RADIUS_MAX;
                } else {
                    this.x = -SPACE_PARTICLE_RADIUS_MAX;
                    this.y = Math.random() * canvas.height;
                }
                 this.radius = Math.random() * (SPACE_PARTICLE_RADIUS_MAX - SPACE_PARTICLE_RADIUS_MIN) + SPACE_PARTICLE_RADIUS_MIN;
                 this.speed = Math.random() * (SPACE_PARTICLE_SPEED_MAX - SPACE_PARTICLE_SPEED_MIN) + SPACE_PARTICLE_SPEED_MIN;
                 this.opacity = Math.random() * 0.8 + 0.2;
                 this.color = `rgba(255, 255, 255, ${this.opacity})`;

                 const targetX = canvas.width / 2;
                 const targetY = canvas.height / 2;
                 const angleToCenter = Math.atan2(targetY - this.y, targetX - this.x);
                 this.vx = Math.cos(angleToCenter) * this.speed * 0.5;
                 this.vy = Math.sin(angleToCenter) * this.speed * 0.5;
            }
        }

        class Player {
            constructor() {
                this.width = PLAYER_SIZE;
                this.height = PLAYER_SIZE;
                this.resetPosition();
                this.color = '#C0C0C0';
                this.shieldColor = 'rgba(0, 150, 255, 0.5)'; 
                this.angle = -Math.PI / 2; // Default to point upwards
                this.prevX = this.x;
                this.prevY = this.y;
                this.dashActive = false;
                this.dashTimer = 0;
                this.lastHunterDamageTime = 0;
            }

            resetPosition() {
                this.x = canvas.width / 2 - this.width / 2;
                this.y = canvas.height - this.height - 40;
                this.prevX = this.x;
                this.prevY = this.y;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.rotate(this.angle + Math.PI / 2);

                if (playerFlashTimer > 0 && Math.floor(performance.now() / 100) % 2 === 0) {
                    ctx.globalAlpha = 0.4;
                }

                // Main body
                ctx.fillStyle = '#C0C0C0';
                ctx.strokeStyle = '#808080';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -this.height / 2);
                ctx.lineTo(-this.width * 0.4, this.height * 0.3);
                ctx.lineTo(-this.width * 0.2, this.height * 0.2);
                ctx.lineTo(this.width * 0.2, this.height * 0.2);
                ctx.lineTo(this.width * 0.4, this.height * 0.3);
                ctx.lineTo(0, -this.height / 2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Cockpit
                ctx.fillStyle = '#77BBDD';
                ctx.strokeStyle = '#5599BB';
                ctx.beginPath();
                ctx.arc(0, -this.height * 0.2, this.width * 0.18, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Rear wings/thrusters
                ctx.fillStyle = '#808080';
                ctx.strokeStyle = '#505050';
                ctx.beginPath();
                ctx.moveTo(-this.width * 0.2, this.height * 0.2);
                ctx.lineTo(-this.width * 0.15, this.height * 0.45);
                ctx.lineTo(this.width * 0.15, this.height * 0.45);
                ctx.lineTo(this.width * 0.2, this.height * 0.2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Small side details
                ctx.fillStyle = '#A0A0A0';
                ctx.beginPath();
                ctx.rect(-this.width * 0.35, this.height * 0.1, this.width * 0.05, this.height * 0.1);
                ctx.rect(this.width * 0.3, this.height * 0.1, this.width * 0.05, this.height * 0.1);
                ctx.fill();

                ctx.restore();

                if (!this.dashActive && ((controlMode === 'mobile' && Math.hypot(joystickDeltaX, joystickDeltaY) > JOYSTICK_DEADZONE) || (controlMode === 'pc' && (keys.w || keys.s || keys.a || keys.d)))) {
                    const thrustX = this.x + this.width / 2 + Math.cos(this.angle + Math.PI) * (this.height * 0.4);
                    const thrustY = this.y + this.height / 2 + Math.sin(this.angle + Math.PI) * (this.height * 0.4);
                    const spreadAngle = 0.6; 

                    for (let i = 0; i < THRUST_PARTICLE_COUNT_PER_FRAME; i++) {
                        const angle = this.angle + Math.PI + (Math.random() - 0.5) * spreadAngle;
                        const speed = Math.random() * THRUST_PARTICLE_MAX_SPEED + (THRUST_PARTICLE_MAX_SPEED * 0.5); 
                        const vx = Math.cos(angle) * speed;
                        const vy = Math.sin(angle) * speed;
                        const radius = Math.random() * (THRUST_PARTICLE_MAX_RADIUS - THRUST_PARTICLE_MIN_RADIUS) + THRUST_PARTICLE_MIN_RADIUS;
                        const life = Math.random() * 0.8 + 0.4; 
                        const color = `rgba(255, ${Math.floor(Math.random() * 100 + 155)}, 0, 1)`; 
                        thrustParticles.push(new Particle(thrustX, thrustY, vx, vy, radius, color, life, THRUST_PARTICLE_DECAY, THRUST_PARTICLE_GRAVITY_FACTOR));
                    }
                }

                if (shieldActive) {
                    ctx.save();
                    ctx.globalAlpha = 0.5 + Math.sin(performance.now() * 0.005) * 0.1;
                    ctx.strokeStyle = 'rgba(0, 200, 255, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'rgba(0, 200, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width * 0.9, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            update(deltaTime) {
                this.prevX = this.x;
                this.prevY = this.y;

                let currentMoveX = 0;
                let currentMoveY = 0;

                if (controlMode === 'mobile') { // Mobile joystick input
                    const magnitudeJoystick = Math.hypot(joystickDeltaX, joystickDeltaY);
                    if (magnitudeJoystick > JOYSTICK_DEADZONE) { // Apply deadzone
                        currentMoveX = joystickDeltaX / JOYSTICK_MAX_DIST;
                        currentMoveY = joystickDeltaY / JOYSTICK_MAX_DIST;
                    }
                } else { // Desktop keyboard input
                    if (keys.w) currentMoveY -= 1;
                    if (keys.s) currentMoveY += 1;
                    if (keys.a) currentMoveX -= 1;
                    if (keys.d) currentMoveX += 1;
                }

                if (keys.shift && controlMode === 'pc') { // Shift is only for desktop
                    playerSpeed = PLAYER_BASE_SPEED * PLAYER_SLOW_SPEED_FACTOR;
                } else {
                    playerSpeed = PLAYER_BASE_SPEED;
                }

                if (!this.dashActive) {
                    const magnitude = Math.hypot(currentMoveX, currentMoveY);
                    if (magnitude > 0) {
                        this.x += (currentMoveX / magnitude) * playerSpeed * deltaTime;
                        this.y += (currentMoveY / magnitude) * playerSpeed * deltaTime;
                    }
                } else {
                    const dashSpeed = PLAYER_BASE_SPEED * 3; 
                    const dashAngle = this.angle; // Dash in current ship direction
                    const dashVx = Math.cos(dashAngle) * dashSpeed * deltaTime;
                    const dashVy = Math.sin(dashAngle) * dashSpeed * deltaTime;

                    this.x += dashVx;
                    this.y += dashVy;
                }

                this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
                this.y = Math.max(0, Math.min(canvas.height - this.height, this.y));

                let targetAngle;
                if (controlMode === 'mobile') { // Mobile aiming logic: touch to fire or auto-aim
                    if (tapToFireActive) {
                        // Try to auto-aim at the closest enemy if there is one
                        let closestEnemy = null;
                        let minDist = Infinity;
                        const autoAimRadius = 400; // Radius for auto-aim
                        enemies.forEach(enemy => {
                            const dist = Math.hypot(player.x + player.width / 2 - (enemy.x + enemy.width / 2),
                                                    player.y + player.height / 2 - (enemy.y + enemy.height / 2));
                            if (dist < minDist && dist < autoAimRadius) {
                                minDist = dist;
                                closestEnemy = enemy;
                            }
                        });

                        if (closestEnemy) {
                            targetAngle = Math.atan2((closestEnemy.y + closestEnemy.height / 2) - (player.y + player.height / 2),
                                                     (closestEnemy.x + closestEnemy.width / 2) - (player.x + player.width / 2));
                        } else { // If no enemies nearby, point towards touch location
                            targetAngle = Math.atan2(tapToFireTargetY - (this.y + this.height / 2), tapToFireTargetX - (this.x + this.width / 2));
                        }
                    } else { // No active touch, maintain current angle (or point upwards by default)
                        targetAngle = this.angle; // Keep the last ship direction
                    }

                } else { // Desktop aiming logic
                    targetAngle = Math.atan2(mouseY - (this.y + this.height / 2), mouseX - (this.x + this.width / 2));
                }
                
                let angleDiff = targetAngle - this.angle;

                if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                const turnAmount = PLAYER_TURN_SPEED * deltaTime;
                if (Math.abs(angleDiff) > turnAmount) {
                    this.angle += Math.sign(angleDiff) * turnAmount;
                } else {
                    this.angle = targetAngle;
                }

                if (this.angle > Math.PI) this.angle -= 2 * Math.PI;
                if (this.angle < -Math.PI) this.angle += 2 * Math.PI;

                if (playerFlashTimer > 0) {
                    playerFlashTimer -= (performance.now() - lastFrameTime);
                }
            }

            takeDamage(damage) {
                if (!shieldActive && !playerInvulnerable) {
                    lives-= damage; // Use damage parameter
                    playerFlashTimer = PLAYER_FLASH_DURATION; 
                    if (lives <= 0) {
                        gameOver = true;
                        endGame();
                    }
                }
            }
        }

        class Bullet {
            constructor(x, y, targetX, targetY, speed, color, isPlayerBullet = true, isHoming = false, isExplosive = false, damagePercent = 0, explosionRadius = 0, damageAmount = 0, isDebuff = false, shieldBreaker = false, ownerType) {
                this.x = x;
                this.y = y;
                this.radius = isPlayerBullet ? 3 : 2; 
                this.speed = speed;
                this.color = color;
                this.isPlayerBullet = isPlayerBullet;
                this.isHoming = isHoming;
                this.isExplosive = isExplosive;
                this.damagePercent = damagePercent; 
                this.explosionRadius = explosionRadius; 
                this.damageAmount = damageAmount; 
                this.isDebuff = isDebuff; 
                this.shieldBreaker = shieldBreaker; // NEW property
                this.target = null;
                this.trail = [];
                this.collided = false; 
                this.ownerType = ownerType;

                if (!this.isHoming) {
                    const angle = Math.atan2(targetY - y, targetX - x);
                    this.dx = Math.cos(angle) * this.speed;
                    this.dy = Math.sin(angle) * this.speed;
                } else {
                    this.findHomingTarget();
                }
            }

            findHomingTarget() {
                if (this.isPlayerBullet) {
                    let closestEnemy = null;
                    let minDist = Infinity;
                    enemies.forEach(enemy => {
                        const dist = Math.hypot(this.x - (enemy.x + enemy.width / 2), this.y - (enemy.y + enemy.height / 2));
                        if (dist < minDist) {
                            minDist = dist;
                            closestEnemy = enemy;
                        }
                    });
                    this.target = closestEnemy;
                } else { // Enemy homing bullet targets the player
                    this.target = player;
                }
            }

            draw() {
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;

                this.trail.forEach(p => {
                    ctx.globalAlpha = p.opacity;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.globalAlpha = 1;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            update(deltaTime) {
                if (this.isHoming && !this.collided) { 
                    if (!this.target || (this.isPlayerBullet && !enemies.includes(this.target))) {
                        this.findHomingTarget();
                    }
                    if (this.target) {
                         const targetX = this.isPlayerBullet ? this.target.x + this.target.width / 2 : this.target.x + this.target.width / 2;
                         const targetY = this.isPlayerBullet ? this.target.y + this.target.height / 2 : this.target.y + this.target.height / 2;
                        const angle = Math.atan2(targetY - this.y, targetX - this.x);
                        this.dx = Math.cos(angle) * this.speed;
                        this.dy = Math.sin(angle) * this.speed;
                    } 
                }
                
                this.x += this.dx * deltaTime;
                this.y += this.dy * deltaTime;

                this.trail.push({
                    x: this.x + (Math.random() - 0.5) * 2,
                    y: this.y + (Math.random() - 0.5) * 2,
                    radius: Math.random() * (this.radius * 0.8) + (this.radius * 0.2),
                    color: this.color + '80',
                    opacity: 0.8
                });
                if (this.trail.length > BULLET_TRAIL_LENGTH) {
                    this.trail.shift();
                }
                 for (let i = this.trail.length - 1; i >= 0; i--) {
                    this.trail[i].opacity -= 0.05 * deltaTime; 
                    if (this.trail[i].opacity <= 0) {
                        this.trail.splice(i, 1);
                    }
                }
            }
        }
        
        class BossBomb {
            constructor(x, y, damage) {
                this.x = x;
                this.y = 0;
                this.targetY = y;
                this.radius = 15;
                this.warningTime = 1500; 
                this.fallTime = 500;
                this.creationTime = performance.now();
                this.state = 'warning'; 
                this.damage = damage;
            }

            draw() {
                const currentTime = performance.now();
                const elapsedTime = currentTime - this.creationTime;

                if(this.state === 'warning') {
                    const pulse = Math.abs(Math.sin(elapsedTime * 0.01));
                    ctx.fillStyle = `rgba(255, 0, 0, ${0.2 + pulse * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.targetY, this.radius * (1 + pulse), 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.state === 'falling') {
                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            update(deltaTime) {
                const currentTime = performance.now();
                const elapsedTime = currentTime - this.creationTime;

                if(this.state === 'warning' && elapsedTime > this.warningTime) {
                    this.state = 'falling';
                }

                if(this.state === 'falling') {
                    this.y += (this.targetY / (this.fallTime / 1000)) * deltaTime;
                    if(this.y >= this.targetY) {
                        this.y = this.targetY;
                        this.state = 'exploded';
                        for (let i = 0; i < 5; i++) {
                           bombFragments.push(new BombFragment(this.x, this.y));
                        }
                        createExplosion(this.x, this.y, 'red', 50, 400, 1, 2, 8);
                        if(checkCollision({x: this.x, y: this.y, radius: this.radius*2}, player)) {
                            player.takeDamage(this.damage);
                        }
                    }
                }
            }
        }
        
        class BombFragment {
            constructor(x,y) {
                this.x = x;
                this.y = y;
                this.radius = 3;
                this.speed = Math.random() * 200 + 100;
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.life = 2; // in seconds
            }

            draw() {
                ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${this.life / 2})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            update(deltaTime) {
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;

                if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > canvas.height) this.vy *= -1;

                this.life -= deltaTime;
            }
        }


        class Enemy {
            constructor(type = 'standard', waveSpeedMultiplier = 1, waveHpMultiplier = 1) {
                this.type = type;
                const baseConfig = ENEMY_BASE_TYPES[this.type] || ENEMY_BASE_TYPES['standard'];

                this.width = baseConfig.size;
                this.height = baseConfig.size;
                this.color = baseConfig.color;
                this.detailColor = baseConfig.detailColor;
                
                let currentHpMultiplier = waveHpMultiplier;
                let currentSpeedMultiplier = waveSpeedMultiplier;
                if (this.type === 'elite' && currentWave > 1) {
                    currentHpMultiplier *= Math.pow(baseConfig.hpMultiplierPerWave, currentWave - 1);
                    currentSpeedMultiplier *= Math.pow(baseConfig.speedMultiplierPerWave, currentWave - 1);
                }

                if (baseConfig.isBoss) { 
                    this.hp = (baseConfig.hp) * currentHpMultiplier;
                    this.bossDrones = []; 
                    this.lastBossDroneSpawnTime = performance.now();
                } else {
                    this.hp = baseConfig.hp * currentHpMultiplier;
                }
                
                this.maxHp = this.hp;
                this.scoreValue = baseConfig.score;
                this.droneChargeValue = baseConfig.droneCharge;
                this.bulletColor = baseConfig.bulletColor;
                this.shootMultiple = baseConfig.shootMultiple;
                this.isBoss = baseConfig.isBoss;
                this.isElite = baseConfig.isElite;
                this.explosionDamage = baseConfig.explosionDamage;
                this.missileDamageMultiplier = baseConfig.missileDamageMultiplier || null;
                this.shieldBreakerBullet = baseConfig.shieldBreakerBullet || false;
                this.spawnsMinions = baseConfig.spawnsMinions || false;
                this.minionSpawnCooldown = baseConfig.minionSpawnCooldown || 5000;
                this.lastMinionSpawnTime = performance.now();
                this.launchesBombs = baseConfig.launchesBombs || false;
                this.bombLaunchCooldown = baseConfig.bombLaunchCooldown || 5000;
                this.lastBombLaunchTime = performance.now();
                this.firesHomingMissiles = baseConfig.firesHomingMissiles || false;
                this.missileLaunchCooldown = baseConfig.missileLaunchCooldown || 5000;
                this.lastMissileLaunchTime = performance.now();
                this.shootsLaser = baseConfig.shootsLaser || false;
                this.laserChargeTime = baseConfig.laserChargeTime || 3000;
                this.laserFireTime = baseConfig.laserFireTime || 1000;
                this.laserCooldown = baseConfig.laserCooldown || 5000;
                this.lastLaserTime = -Infinity;
                this.isChargingLaser = false;
                this.laserChargeStart = 0;

                this.speed = (Math.random() * (baseConfig.speed.max - baseConfig.speed.min) + baseConfig.speed.min) * currentSpeedMultiplier;
                
                this.dx = 0;
                this.dy = 0;
                this.resetPosition();

                this.lastShotTime = performance.now();
                const minCooldown = baseConfig.bulletCooldownMin || ENEMY_BULLET_COOLDOWN_MIN;
                const maxCooldown = baseConfig.bulletCooldownMax || ENEMY_BULLET_COOLDOWN_MAX;
                this.shotCooldown = Math.random() * (maxCooldown - minCooldown) + minCooldown;
                
                this.isAccelerating = false; 
                this.accelerationTimer = 0;
                this.flickerTimer = 0;
            }

            resetPosition() {
                if (this.type === 'artillery_alien') {
                    this.x = canvas.width / 2 - this.width / 2;
                    this.y = 50;
                    this.dx = 0;
                    this.dy = 0;
                    return;
                }
                const side = Math.floor(Math.random() * 4);
                if (side === 0) { 
                    this.x = Math.random() * (canvas.width - this.width);
                    this.y = -this.height;
                } else if (side === 1) { 
                    this.x = canvas.width;
                    this.y = Math.random() * (canvas.height - this.height);
                } else if (side === 2) { 
                    this.x = Math.random() * (canvas.width - this.width);
                    this.y = canvas.height;
                } else { 
                    this.x = -this.width;
                    this.y = Math.random() * (canvas.height - this.height);
                }

                if (this.isBoss) {
                    this.x = Math.random() * (canvas.width - this.width); // Random X position for bosses
                    this.y = -this.height; 
                    this.dx = 0; 
                    this.dy = this.speed * 0.5; 
                } else if (player && this.type !== 'exploder' && this.type !== 'hunter_minion') {
                    const angleToPlayer = Math.atan2(player.y + player.height / 2 - (this.y + this.height / 2),
                                                     player.x + player.width / 2 - (this.x + this.width / 2));
                    this.dx = Math.cos(angleToPlayer) * this.speed;
                    this.dy = Math.sin(angleToPlayer) * this.speed;
                } else if (player) {
                     const angleToPlayer = Math.atan2(player.y + player.height / 2 - (this.y + this.height / 2),
                                                     player.x + player.width / 2 - (this.x + this.width / 2));
                    this.dx = Math.cos(angleToPlayer) * this.speed;
                    this.dy = Math.sin(angleToPlayer) * this.speed;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);

                if (this.flickerTimer > 0 && Math.floor(performance.now() / 50) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }

                const baseConfig = ENEMY_BASE_TYPES[this.type] || ENEMY_BASE_TYPES['standard'];
                ctx.fillStyle = baseConfig.color;
                ctx.strokeStyle = baseConfig.detailColor;
                ctx.lineWidth = 2;

                if (this.type === 'hunter') {
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = this.detailColor;
                    
                    // "Eyes"
                    ctx.beginPath();
                    ctx.moveTo(-this.width * 0.3, -this.height * 0.2);
                    ctx.lineTo(-this.width * 0.1, 0);
                    ctx.lineTo(-this.width * 0.3, this.height * 0.2);
                    ctx.closePath();
                    ctx.moveTo(this.width * 0.3, -this.height * 0.2);
                    ctx.lineTo(this.width * 0.1, 0);
                    ctx.lineTo(this.width * 0.3, this.height * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // "Mouth"
                    ctx.beginPath();
                    ctx.arc(0, this.height * 0.1, this.width * 0.25, 0, Math.PI, false);
                    ctx.lineWidth = 6;
                    ctx.stroke();
                } else if (this.type === 'hunter_minion'){
                    ctx.lineWidth = 1;
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = this.detailColor;
                    ctx.beginPath();
                    ctx.moveTo(0, -this.height/2);
                    ctx.lineTo(-this.width/2, this.height/2);
                    ctx.lineTo(this.width/2, this.height/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (this.type === 'boss' || this.type === 'artillery_alien' || this.type === 'skull_overlord') {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                     if (this.type === 'skull_overlord') {
                        // Draw skull
                        ctx.fillStyle = baseConfig.detailColor;
                        ctx.beginPath();
                        ctx.arc(-this.width * 0.15, -this.height * 0.15, this.width * 0.1, 0, Math.PI * 2);
                        ctx.arc(this.width * 0.15, -this.height * 0.15, this.width * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillRect(-this.width * 0.05, 0, this.width*0.1, this.height * 0.2);
                    }
                } else {
                    ctx.beginPath();
                    ctx.rect(-this.width/2, -this.height/2, this.width, this.height);
                    ctx.fill();
                    ctx.stroke();
                }
                
                ctx.restore();

                // HP Bar
                const hpBarWidth = this.width * 0.8;
                const hpBarHeight = 4; 
                const hpRatio = this.hp / this.maxHp;
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x + this.width / 2 - hpBarWidth / 2, this.y - 12, hpBarWidth, hpBarHeight); 
                ctx.fillStyle = 'lime';
                ctx.fillRect(this.x + this.width / 2 - hpBarWidth / 2, this.y - 12, hpBarWidth * hpRatio, hpBarHeight);
            }

            update(deltaTime) {
                const currentTime = performance.now();
                const baseConfig = ENEMY_BASE_TYPES[this.type];

                if (this.flickerTimer > 0) {
                    this.flickerTimer -= (performance.now() - lastFrameTime); 
                }

                if (this.isBoss) {
                    if(this.type !== 'artillery_alien') {
                        if (this.y < (canvas.height / 4) && this.dy > 0) {
                            // Still moving down to position
                        } else if (this.dy > 0) { 
                            this.y = canvas.height / 4;
                            this.dy = 0; 
                            this.dx = this.speed * (Math.random() > 0.5 ? 1 : -1);
                        }
                
                        // Ricochet logic
                        if (this.dx !== 0) {
                            if (this.x + this.width >= canvas.width && this.dx > 0) {
                                this.dx *= -1;
                                this.x = canvas.width - this.width;
                            }
                            if (this.x <= 0 && this.dx < 0) {
                                this.dx *= -1;
                                this.x = 0;
                            }
                        }
                    }

                    // Special attacks
                    if(this.launchesBombs && currentTime - this.lastBombLaunchTime > this.bombLaunchCooldown) {
                        let bombDamage = this.type === 'hunter' ? 10 : 50;
                        bossBombs.push(new BossBomb(Math.random() * canvas.width, canvas.height, bombDamage));
                        this.lastBombLaunchTime = currentTime;
                    }

                    if(this.firesHomingMissiles && currentTime - (this.lastMissileLaunchTime || 0) > this.missileLaunchCooldown){
                        enemyBullets.push(new Bullet(this.x + this.width/2, this.y + this.height/2, player.x, player.y, 300, 'purple', false, true));
                        this.lastMissileLaunchTime = currentTime;
                    }

                     if(baseConfig.shootsLaser && currentTime - (this.lastLaserTime || 0) > baseConfig.laserCooldown && !this.isChargingLaser) {
                        this.isChargingLaser = true;
                        this.laserChargeStart = currentTime;
                    }

                    if(this.isChargingLaser) {
                        const chargeElapsed = currentTime - this.laserChargeStart;
                        // Draw charging animation
                        if (chargeElapsed > baseConfig.laserChargeTime) {
                           // Fire laser
                           this.isChargingLaser = false;
                           this.lastLaserTime = currentTime;
                           // Laser damage logic would go here, likely in the main game loop
                        }
                    }
            
                } else if (this.type === 'hunter_minion' && player) {
                    const angleToPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                    const distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
                    const idealDist = 300; // Keep distance
                    if (distToPlayer > idealDist) {
                         this.dx = Math.cos(angleToPlayer) * this.speed;
                         this.dy = Math.sin(angleToPlayer) * this.speed;
                    } else {
                        this.dx = -Math.cos(angleToPlayer) * this.speed * 0.5;
                        this.dy = -Math.sin(angleToPlayer) * this.speed * 0.5;
                    }
                } else if (player) {
                     const angleToPlayer = Math.atan2(player.y + player.height / 2 - (this.y + this.height / 2),
                                                     player.x + player.width / 2 - (this.x + this.width / 2));
                    this.dx = Math.cos(angleToPlayer) * this.speed;
                    this.dy = Math.sin(angleToPlayer) * this.speed;
                }
                
                this.x += this.dx * deltaTime;
                this.y += this.dy * deltaTime;


                if (player && currentTime - this.lastShotTime > this.shotCooldown && baseConfig.shootMultiple > 0) {
                    const bulletSpeed = baseConfig.bulletSpeed || ENEMY_BULLET_SPEED;
                    const isShieldBreaker = this.shieldBreakerBullet;

                    if (this.type === 'boss') { 
                        const angleStep = Math.PI * 2 / this.shootMultiple;
                        for (let i = 0; i < this.shootMultiple; i++) {
                            const angle = i * angleStep + performance.now() * 0.0005;
                            enemyBullets.push(new Bullet(this.x + this.width / 2, this.y + this.height / 2,
                                                         this.x + this.width / 2 + Math.cos(angle) * 100,
                                                         this.y + Math.sin(angle) * 100,
                                                         bulletSpeed, this.bulletColor, false, false, false, 0, 0, 0, false, false, this.type));
                        }
                    } else if (this.type === 'hunter_minion' || this.type === 'artillery_alien' || this.type === 'skull_minion' || this.type === 'standard' || this.type === 'chaser' || this.type === 'tank') {
                         enemyBullets.push(new Bullet(this.x + this.width / 2, this.y + this.height / 2,
                                                     player.x + player.width / 2, player.y + player.height / 2,
                                                     bulletSpeed, this.bulletColor, false, baseConfig.isHoming, false, 0, 0, 0, false, false, this.type));
                    } else if(baseConfig.shootMultiple > 1) { // Standard multi-shooter logic
                         const targetAngle = Math.atan2(player.y + player.height / 2 - (this.y + this.height / 2),
                                                       player.x + player.width / 2 - (this.x + this.width / 2));
                        const spread = Math.PI / 8; 
                        for (let i = -Math.floor(this.shootMultiple/2); i <= Math.floor(this.shootMultiple/2); i++) {
                            const angle = targetAngle + i * spread;
                            enemyBullets.push(new Bullet(this.x + this.width / 2, this.y + this.height / 2,
                                                         this.x + this.width / 2 + Math.cos(angle) * 100,
                                                         this.y + Math.sin(angle) * 100,
                                                         bulletSpeed, this.bulletColor, false, false, this.type === 'heavy_shooter', 0, 40, false, isShieldBreaker, this.type)); 
                        }
                    } else { // All other single-shot enemies
                         enemyBullets.push(new Bullet(this.x + this.width / 2, this.y + this.height / 2,
                                                     player.x + player.width / 2, player.y + player.height / 2,
                                                     bulletSpeed, this.bulletColor, false, baseConfig.isHoming, false, 0, 0, 0, this.type === 'disruptor', isShieldBreaker, this.type));
                    }

                    this.lastShotTime = currentTime;
                    const minCooldown = baseConfig.bulletCooldownMin || ENEMY_BULLET_COOLDOWN_MIN;
                    const maxCooldown = baseConfig.bulletCooldownMax || ENEMY_BULLET_COOLDOWN_MAX;
                    this.shotCooldown = Math.random() * (maxCooldown - minCooldown) + minCooldown;
                }
            }

            takeDamage(damage) {
                this.hp -= damage;
                this.flickerTimer = 100;
                if (this.hp <= 0) {
                    return true;
                }
                return false;
            }
        }

        class Drone { 
            constructor(offsetIndex, temporary = false, life = Infinity) {
                if(!player) return;
                this.offsetIndex = offsetIndex;
                this.x = player.x + DRONE_OFFSETS[this.offsetIndex].x;
                this.y = player.y + DRONE_OFFSETS[this.offsetIndex].y;
                this.width = DRONE_SIZE;
                this.height = DRONE_SIZE;
                this.color = temporary ? '#FF8C00' : '#A020F0';
                this.detailColor = temporary ? '#FFA500' : '#D8BFD8';
                this.hp = DRONE_HP;
                this.maxHp = DRONE_HP;
                this.lastShotTime = performance.now();
                this.currentTarget = null;
                this.temporary = temporary;
                this.spawnTime = performance.now();
                this.life = life;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#6A0DAD';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.rect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = this.detailColor;
                ctx.beginPath();
                ctx.arc(0, 0, this.width * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Side cannons
                ctx.fillStyle = '#606060';
                ctx.beginPath();
                ctx.rect(-this.width / 2 - 5, -5, 5, 10);
                ctx.rect(this.width / 2, -5, 5, 10);
                ctx.fill();

                ctx.restore();

                // HP Bar
                const hpBarWidth = this.width;
                const hpBarHeight = 3;
                const hpRatio = this.hp / this.maxHp;
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - hpBarWidth / 2, this.y - this.height / 2 - hpBarHeight - 5, hpBarWidth, hpBarHeight);
                ctx.fillStyle = 'lime';
                ctx.fillRect(this.x - hpBarWidth / 2, this.y - this.height / 2 - hpBarHeight - 5, hpBarWidth * hpRatio, hpBarHeight);
            }

            update(deltaTime) {
                if (!player) return;

                this.x = player.x + player.width / 2 + DRONE_OFFSETS[this.offsetIndex % DRONE_OFFSETS.length].x;
                this.y = player.y + player.height / 2 + DRONE_OFFSETS[this.offsetIndex % DRONE_OFFSETS.length].y;

                const currentTime = performance.now();
                if (currentTime - this.lastShotTime > DRONE_BULLET_COOLDOWN) {
                    if (this.currentTarget && !enemies.includes(this.currentTarget)) {
                        this.currentTarget = null;
                    }

                    let targetEnemy = null;
                    let minDist = Infinity;
                    enemies.forEach(enemy => {
                        const dist = Math.hypot(this.x - (enemy.x + enemy.width / 2), this.y - (enemy.y + enemy.height / 2));
                        if (dist < minDist) {
                            minDist = dist;
                            targetEnemy = enemy;
                        }
                    });

                    if (targetEnemy) {
                        this.currentTarget = targetEnemy;
                        bullets.push(new Bullet(this.x, this.y, targetEnemy.x + targetEnemy.width / 2, targetEnemy.y + targetEnemy.height / 2, DRONE_BULLET_SPEED, 'purple'));
                    }
                    this.lastShotTime = currentTime;
                }
            }

            takeDamage(damage) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    return true;
                }
                return false;
            }
        }

        class DefenseDrone { 
            constructor(index) {
                this.index = index;
                this.x = 0; 
                this.y = 0; 
                this.width = DEFENSE_DRONE_SIZE;
                this.height = DEFENSE_DRONE_SIZE;
                this.color = '#B22222';
                this.detailColor = '#F08080';
                this.hp = DEFENSE_DRONE_HP;
                this.maxHp = DEFENSE_DRONE_HP;
                this.orbitAngle = (Math.PI * 2 / DEFENSE_DRONE_MAX) * index; 
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#8B0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = this.detailColor; 
                ctx.beginPath();
                ctx.rect(-this.width * 0.1, -this.height * 0.4, this.width * 0.2, this.height * 0.8);
                ctx.fill();
                ctx.stroke();

                ctx.restore();

                // HP Bar
                const hpBarWidth = this.width * 0.8;
                const hpBarHeight = 3;
                const hpRatio = this.hp / this.maxHp;
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - hpBarWidth / 2, this.y - this.height / 2 - hpBarHeight - 5, hpBarWidth, hpBarHeight);
                ctx.fillStyle = 'lime';
                ctx.fillRect(this.x - hpBarWidth / 2, this.y - this.height / 2 - hpBarHeight - 5, hpBarWidth * hpRatio, hpBarHeight);
            }

            update(deltaTime) {
                if (!player) return;

                this.orbitAngle += DEFENSE_DRONE_ORBIT_SPEED * deltaTime;

                this.x = player.x + player.width / 2 + Math.cos(this.orbitAngle) * DEFENSE_DRONE_RADIUS;
                this.y = player.y + player.height / 2 + Math.sin(this.orbitAngle) * DEFENSE_DRONE_RADIUS;
            }

            takeDamage(damage) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    return true;
                }
                return false;
            }
        }

        class SpecialDrone { 
            constructor() {
                this.x = player.x + SPECIAL_DRONE_OFFSETS[0].x;
                this.y = player.y + SPECIAL_DRONE_OFFSETS[0].y;
                this.width = SPECIAL_DRONE_SIZE;
                this.height = SPECIAL_DRONE_SIZE;
                this.color = '#FF4500';
                this.detailColor = '#FFFF00';
                this.hp = SPECIAL_DRONE_HP;
                this.maxHp = SPECIAL_DRONE_HP;
                this.lastShotTime = performance.now();
                this.currentTarget = null; 
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#B22222';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -this.height / 2);
                ctx.lineTo(-this.width / 2, this.height / 2);
                ctx.lineTo(this.width / 2, this.height / 2);
                ctx.closePath();
                ctx.fill(); 
                ctx.stroke();

                ctx.fillStyle = this.detailColor; 
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'yellow';
                ctx.beginPath();
                ctx.arc(0, 0, this.width * 0.25, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.restore();

                // HP Bar
                const hpBarWidth = this.width;
                const hpBarHeight = 3;
                const hpRatio = this.hp / this.maxHp;
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - hpBarWidth / 2, this.y - this.height / 2 - hpBarHeight - 5, hpBarWidth, hpBarHeight);
                ctx.fillStyle = 'lime';
                ctx.fillRect(this.x - hpBarWidth / 2, this.y - this.height / 2 - hpBarHeight - 5, hpBarWidth * hpRatio, hpBarHeight);
            }

            update(deltaTime) {
                if (!player) return;
                
                this.x = player.x + player.width / 2 + SPECIAL_DRONE_OFFSETS[0].x;
                this.y = player.y + player.height / 2 + SPECIAL_DRONE_OFFSETS[0].y;

                const currentTime = performance.now();
                if (currentTime - this.lastShotTime > SPECIAL_DRONE_BULLET_COOLDOWN) {
                    const numBullets = 8; 
                    for (let i = 0; i < numBullets; i++) {
                        const angle = (Math.PI * 2 / numBullets) * i;
                        bullets.push(new Bullet(this.x, this.y,
                                                this.x + Math.cos(angle) * 100,
                                                this.y + Math.sin(angle) * 100,
                                                SPECIAL_DRONE_BULLET_SPEED, 'gold', true, false, true, 0, SPECIAL_DRONE_BULLET_EXPLOSION_RADIUS, SPECIAL_DRONE_BULLET_DAMAGE)); 
                    }
                    this.lastShotTime = currentTime;
                }
            }

            takeDamage(damage) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    return true;
                }
                return false;
            }
        }

        class BossDrone {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = BOSS_DRONE_SIZE; 
                this.height = BOSS_DRONE_SIZE;
                this.hp = BOSS_DRONE_HP; 
                this.maxHp = BOSS_DRONE_HP;
                this.color = '#FFA500';
                this.detailColor = '#FFD700';
                this.speed = BOSS_DRONE_SPEED; 
                this.lastShotTime = performance.now();
                this.bulletCooldown = BOSS_DRONE_BULLET_COOLDOWN; 
                this.bulletSpeed = BOSS_DRONE_BULLET_SPEED;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#FF8C00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = this.detailColor;
                ctx.beginPath();
                ctx.moveTo(0, -this.height * 0.4);
                ctx.lineTo(-this.width * 0.2, this.height * 0.2);
                ctx.lineTo(this.width * 0.2, this.height * 0.2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.restore();

                // HP Bar
                const hpBarWidth = this.width * 0.8;
                const hpBarHeight = 3;
                const hpRatio = this.hp / this.maxHp;
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - hpBarWidth / 2, this.y - this.height / 2 - hpBarHeight - 5, hpBarWidth, hpBarHeight);
                ctx.fillStyle = 'lime';
                ctx.fillRect(this.x - hpBarWidth / 2, this.y - this.height / 2 - hpBarHeight - 5, hpBarWidth * hpRatio, hpBarHeight);
            }

            update(deltaTime) {
                if (!player) return;

                // Move towards player
                const angleToPlayer = Math.atan2(player.y + player.height / 2 - this.y, player.x + player.width / 2 - this.x);
                this.x += Math.cos(angleToPlayer) * this.speed * deltaTime;
                this.y += Math.sin(angleToPlayer) * this.speed * deltaTime;

                // Shoot at player
                const currentTime = performance.now();
                if (currentTime - this.lastShotTime > this.bulletCooldown) {
                    enemyBullets.push(new Bullet(this.x, this.y, player.x + player.width / 2, player.y + player.height / 2, this.bulletSpeed, this.color, false));
                    this.lastShotTime = currentTime;
                }
            }

            takeDamage(damage) {
                this.hp -= damage;
                if (this.hp <= 0) {
                    return true;
                }
                return false;
            }
        }


        class Pickup {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 25; 
                this.height = 25; 
                this.type = type;
                this.color = 'white';
                this.speed = 100; 

                switch(this.type) {
                    case 'life': this.color = 'limegreen'; break;
                    case 'shield': this.color = 'dodgerblue'; break;
                    case 'drone': this.color = 'gold'; break;
                    case 'missile': this.color = 'red'; break;
                    case 'rapidfire': this.color = 'hotpink'; break; 
                    case 'tripleshot': this.color = 'orange'; break; 
                }
            }

            draw() {
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;

                ctx.fillStyle = this.color + '50';
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);

                ctx.fillStyle = this.color; 
                ctx.font = 'bold 18px Share Tech Mono'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                let displayText = '';
                switch(this.type) {
                    case 'life': displayText = '+'; break;
                    case 'shield': displayText = 'S'; break;
                    case 'drone': displayText = 'D'; break;
                    case 'missile': displayText = 'M'; break;
                    case 'rapidfire': displayText = 'F'; break;
                    case 'tripleshot': displayText = 'T'; break;
                    default: displayText = '?'; break;
                }
                ctx.fillText(displayText, this.x, this.y + 2);

                ctx.restore();
            }

            update(deltaTime) {
                this.y += this.speed * deltaTime;
            }
        }

        function createExplosion(x, y, baseColor, numParticles = 20, particleSpeed = 250, particleDecay = 2, minRadius = 1, maxRadius = 3, hasGravity = false) { 
            // Limit the number of particles generated for optimization
            numParticles = Math.min(numParticles, 20); 

            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * particleSpeed + (particleSpeed * 0.5);
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                const radius = Math.random() * (maxRadius - minRadius) + minRadius;
                const life = Math.random() * 0.8 + 0.4; 
                let color;
                if (baseColor === 'red' || baseColor === 'orange' || baseColor === '#FF4500' || baseColor === '#FF6600') {
                    color = `rgb(${Math.floor(Math.random() * 80 + 175)}, ${Math.floor(Math.random() * 100)}, 0)`;
                } else if (baseColor === 'white' || baseColor === 'cyan' || baseColor === 'lightblue' || baseColor === '#66FFFF') {
                    color = `rgb(${Math.floor(Math.random() * 50 + 200)}, ${Math.floor(Math.random() * 50 + 200)}, ${Math.floor(Math.random() * 50 + 200)})`;
                } else if (baseColor === 'gray') {
                    color = `rgb(${Math.floor(Math.random() * 50 + 150)}, ${Math.floor(Math.random() * 50 + 150)}, ${Math.floor(Math.random() * 50 + 150)})`;
                } else if (baseColor === '#8B008B' || baseColor === 'darkviolet') { 
                     color = `rgb(${Math.floor(Math.random() * 50 + 150)}, 0, ${Math.floor(Math.random() * 50 + 150)})`;
                } else if (baseColor === '#FFD700' || baseColor === 'gold') { 
                    color = `rgb(${Math.floor(Math.random() * 50 + 200)}, ${Math.floor(Math.random() * 50 + 200)}, 0)`;
                } else if (baseColor === '#B22222' || baseColor === 'darkred' || baseColor === '#ff0000') {
                    color = `rgb(${Math.floor(Math.random() * 50 + 170)}, ${Math.floor(Math.random() * 50 + 20)}, ${Math.floor(Math.random() * 50 + 20)})`;
                }
                else {
                    color = baseColor;
                }
                particles.push(new Particle(x, y, vx, vy, radius, color, life, particleDecay, hasGravity ? 0.2 : 0));
            }
        }

        function initStars() {
            for (let i = 0; i < NUM_STARS; i++) {
                stars.push(new Star());
            }
        }

        function initSpaceParticles() {
            for (let i = 0; i < NUM_SPACE_PARTICLES; i++) {
                spaceParticles.push(new SpaceParticle());
            }
        }

        // --- UI and Game Management Functions ---

        function showScreen(screenId) {
            // First, hide all main screens and game elements
            mainScreen.style.display = 'none';
            tutorialScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            challengeModal.style.display = 'none';
            canvas.style.display = 'none';
            bottomBarMenu.style.display = 'none'; 
            reticle.style.display = 'none';
            mobileControls.style.display = 'none'; 
            orientationMessage.style.display = 'none'; // Hide orientation message

            // Stop any active game loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Based on screenId, show the appropriate screen and its specific elements
            if (screenId === 'main') {
                mainScreen.style.display = 'flex';
                loadHighScores();
            } else if (screenId === 'tutorial') {
                tutorialScreen.style.display = 'flex';
            } else if (screenId === 'game') {
                // If mobile control mode is selected, check orientation
                if (controlMode === 'mobile' && checkOrientation()) {
                    // checkOrientation will display the message and stop here if in portrait
                    return; 
                }

                canvas.style.display = 'block';
                bottomBarMenu.style.display = 'flex'; 

                // Show desktop-specific reticle or mobile-specific controls based on selected controlMode
                if (controlMode === 'pc') { 
                    reticle.style.display = 'block';
                    mobileControls.style.display = 'none';
                } else if (controlMode === 'mobile') { 
                    reticle.style.display = 'none';
                    mobileControls.style.display = 'block';
                }
                
                // Start the game loop if not already running
                if (!animationFrameId) {
                    lastFrameTime = performance.now(); 
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
            } else if (screenId === 'gameover') {
                gameOverScreen.style.display = 'flex';
                finalScoreDisplay.textContent = score;
            }
            updateMenuDisplay(); // Always update menu display after changing screens
        }


        function startGame(startControlMode, startIsChallengeMode) {
            controlMode = startControlMode;
            isChallengeMode = startIsChallengeMode;

            playerName = playerNameInput.value.trim();
            if (playerName === "") {
                playerName = "Jogador";
            }
            
            showScreen('game');

            player = new Player();
            bullets = [];
            enemies = [];
            enemyBullets = [];
            particles = [];
            thrustParticles = [];
            stars = [];
            spaceParticles = [];
            drones = [];
            defenseDrones = []; 
            specialDrone = null; 
            bossDrones = []; 
            bossBombs = [];
            pickups = [];
            score = 0;

            if(isChallengeMode) {
                lives = 1;
                maxLives = 60;
                DRONE_MAX_DRONES = 5;
                nextDroneUpgradeScore = 5000;
            } else {
                lives = 3;
                maxLives = 90;
                DRONE_MAX_DRONES = 5;
            }

            gameOver = false;
            mouseIsDown = false; 
            tapToFireActive = false; 
            tapToFireTargetX = 0;
            tapToFireTargetY = 0;
            droneCharge = 0;
            pointsForNextLife = 2000;
            currentWave = 1;

            bombCount = 0; 
            lastBombChargeTime = performance.now(); 

            // Reset score multiplier
            scoreMultiplierActive = false;
            scoreMultiplierTimer = 0;
            lastScoreMultiplierActivation = -Infinity;

            // Reset Head Shot
            headShotAvailable = false;
            headShotActive = false;
            headShotCooldown = 40000;
            lastHeadShotActivation = -Infinity;
            

            nextBossSpawnScore = 1000; 
            nextMegaBossSpawnScore = 10000; 
            nextHunterSpawnScore = 20000;
            nextArtillerySpawnScore = 30000;
            nextSkullOverlordSpawnScore = 100000;

            // Start with missile slots ready
            missileSlots = [];
            for (let i = 0; i < 5; i++) {
                missileSlots.push({ readyTime: 0 });
            }

            lastPlayerShotTime = 0;
            shieldActive = false;
            shieldTimer = 0;
            lastShieldActivation = -SHIELD_COOLDOWN;
            lastEnemySpawnTime = 0;
            bossActive = false; 
            megaBossWaveActive = false; 
            hunterWaveActive = false;
            body.classList.remove('apocalypse-active');
            
            rapidFireActive = false;
            rapidFireTimer = 0;
            tripleShotActive = false;
            tripleShotTimer = 0;
            predatorActive = false; 
            predatorTimer = 0;
            lastPredatorActivation = -PREDATOR_COOLDOWN; 
            playerBulletCooldown = PLAYER_BASE_BULLET_COOLDOWN; 
            
            playerBulletCooldownSlowed = false; 
            playerBulletCooldownSlowedTimer = 0; 

            currentEnergy = MAX_ENERGY; 
            lastEnergyRegenTime = performance.now();
            playerInvulnerable = false; 
            playerInvulnerableTimer = 0;
            playerFlashTimer = 0;

            // Reset joystick states
            joystickActive = false;
            joystickDeltaX = 0;
            joystickDeltaY = 0;
            if (joystickInner) {
                joystickInner.style.transform = `translate(0px, 0px)`;
                joystickInner.classList.remove('active');
            }
            if (joystickArea) {
                joystickArea.classList.remove('active');
            }


            resizeCanvas();
            initStars();
            initSpaceParticles();

            updateMenuDisplay();
            lastFrameTime = performance.now(); 
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameOver = true;
            saveHighScore(playerName, score);
            showScreen('gameover');
            body.classList.remove('apocalypse-active');
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function addScore(points) {
            let pointsToAdd = points;
             if (!isChallengeMode && scoreMultiplierActive) {
                pointsToAdd *= GAME_SCORE_MULTIPLIER_AMOUNT;
            }
            score += pointsToAdd;

            if (score >= 100000) {
                if (!headShotAvailable) {
                    headShotAvailable = true;
                }
                maxLives = 60;
                if(lives > maxLives) {
                    lives = maxLives;
                }
            }

            if(isChallengeMode && score >= nextDroneUpgradeScore && DRONE_MAX_DRONES < 15){
                DRONE_MAX_DRONES++;
                nextDroneUpgradeScore += 5000;
            }
            
            const oldWave = currentWave;
            currentWave = Math.floor(score / 10000) + 1;
            if(currentWave > oldWave) {
                console.log(`Wave ${currentWave} initiated!`);
            }

            while (score >= pointsForNextLife) {
                if (lives < maxLives) {
                    lives++;
                }
                if (score < 30000) {
                    pointsForNextLife += 2000; 
                } else if (score < 100000) {
                    pointsForNextLife += 10000;
                } else {
                    pointsForNextLife += 20000;
                }
            }

            // Spawn logic, prioritizing more difficult bosses
             if (score >= nextSkullOverlordSpawnScore && !bossActive) {
                spawnSkullOverlordWave();
                nextSkullOverlordSpawnScore = score + 100000;
            } else if (score >= nextArtillerySpawnScore && !bossActive) {
                 spawnArtilleryWave();
                 nextArtillerySpawnScore = score + 10000;
            } else if (score >= nextHunterSpawnScore && !bossActive) {
                spawnHunterWave();
                nextHunterSpawnScore = score + 20000; 
            } else if (score >= nextMegaBossSpawnScore && !bossActive) {
                spawnMegaBossWave();
                nextMegaBossSpawnScore = score + 10000;
            } else if (score >= nextBossSpawnScore && !bossActive) {
                spawnBoss();
                nextBossSpawnScore = score + 1000;
            }
            
            updateMenuDisplay();
        }

        function saveHighScore(name, score) {
            let highScores = JSON.parse(localStorage.getItem('spaceGameHighScores')) || [];
            highScores.push({ name: name, score: score });
            
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 10);

            localStorage.setItem('spaceGameHighScores', JSON.stringify(highScores));
            loadHighScores();
        }

        function loadHighScores() {
            let highScores = JSON.parse(localStorage.getItem('spaceGameHighScores')) || [];
            highScoresBody.innerHTML = '';

            if (highScores.length === 0) {
                highScoresBody.innerHTML = '<tr><td colspan="3">Nenhum recorde ainda!</td></tr>';
                return;
            }

            highScores.forEach((entry, index) => {
                const row = highScoresBody.insertRow();
                row.insertCell().textContent = index + 1;
                row.insertCell().textContent = entry.name;
                row.insertCell().textContent = entry.score;
            });
        }

        function updateMenuDisplay() {
            const currentTime = performance.now();

            scoreDisplay.textContent = `${score}`;
            waveDisplay.textContent = `${currentWave}`;
            livesDisplay.textContent = `${lives}`;
            
            const isMobileMode = controlMode === 'mobile';
            const essentialMobileItems = ['score-item', 'wave-item', 'lives-item'];

            if (isMobileMode) {
                bottomBarMenu.classList.add('mobile-simplified');
            } else {
                bottomBarMenu.classList.remove('mobile-simplified');
            }

            document.querySelectorAll('#bottom-bar-menu .menu-item').forEach(item => {
                const itemId = item.id;
                
                if (itemId === 'score-multi-item') {
                    item.style.display = isChallengeMode ? 'none' : 'flex';
                }
                
                if (itemId === 'headshot-item' && !headShotAvailable) {
                    item.style.display = 'none';
                    return;
                }
                
                if (isMobileMode) {
                    if(!essentialMobileItems.includes(itemId)) {
                        item.style.display = 'none';
                    }
                } else {
                    item.style.display = 'flex';
                }
            });

            // Head Shot UI
            if (headShotAvailable) {
                headshotItem.style.display = 'flex';
                const timeSinceLastHeadshot = currentTime - lastHeadShotActivation;
                if (headShotActive) {
                    headshotStatusText.textContent = `Active`;
                    headshotItem.classList.add('active');
                    headshotItem.classList.remove('ready', 'recharging', 'not-ready');
                } else {
                    if (timeSinceLastHeadshot >= headShotCooldown) {
                        headshotStatusText.textContent = 'Ready';
                        headshotItem.classList.add('ready');
                        headshotItem.classList.remove('active', 'recharging', 'not-ready');
                    } else {
                        const timeLeft = Math.ceil((headShotCooldown - timeSinceLastHeadshot) / 1000);
                        headshotStatusText.textContent = `${timeLeft}s`;
                        headshotItem.classList.add('recharging');
                        headshotItem.classList.remove('active', 'ready', 'not-ready');
                    }
                }
            } else {
                 headshotItem.style.display = 'none';
            }


            // Shield update
            const timeSinceLastShield = currentTime - lastShieldActivation;
            if (shieldActive) {
                shieldStatusText.textContent = `Active`;
                shieldItem.classList.add('active');
                shieldItem.classList.remove('ready', 'recharging', 'not-ready');
            } else {
                if (timeSinceLastShield >= SHIELD_COOLDOWN) { 
                    shieldStatusText.textContent = 'Ready';
                    shieldItem.classList.add('ready');
                    shieldItem.classList.remove('active', 'recharging', 'not-ready');
                } else {
                    const timeLeft = Math.ceil((SHIELD_COOLDOWN - timeSinceLastShield) / 1000);
                    shieldStatusText.textContent = `${timeLeft}s`;
                    shieldItem.classList.add('recharging');
                    shieldItem.classList.remove('active', 'ready', 'not-ready');
                }
            }

            energyStatusText.textContent = `${Math.floor(currentEnergy)}%`;
            if (currentEnergy >= DASH_COST) {
                dashAbilityText.textContent = 'Ready';
                dashItem.classList.add('ready');
                dashItem.classList.remove('not-ready', 'recharging');
                energyItem.classList.add('ready');
                energyItem.classList.remove('not-ready');
            } else {
                dashAbilityText.textContent = 'Unavailable';
                dashItem.classList.remove('ready');
                dashItem.classList.add('not-ready');
                energyItem.classList.remove('ready');
                energyItem.classList.add('not-ready');
            }


            dronePointsText.textContent = `${droneCharge}/${DRONE_ACTIVATION_COST}`;
            if (droneCharge >= DRONE_ACTIVATION_COST && drones.length < DRONE_MAX_DRONES) {
                droneCombatItem.classList.add('ready');
                droneCombatItem.classList.remove('not-ready');
            } else {
                droneCombatItem.classList.remove('ready');
                droneCombatItem.classList.add('not-ready');
            }
            
            missileSlotsText.innerHTML = '';
            let missilesReadyCount = 0;
            missileSlots.forEach((slot) => {
                const span = document.createElement('span');
                span.classList.add('missile-display');
                if (slot.readyTime <= currentTime) {
                    span.textContent = '●';
                    span.classList.add('ready');
                    missilesReadyCount++;
                } else {
                    const timeLeft = Math.ceil((slot.readyTime - currentTime) / 1000);
                    span.textContent = `${timeLeft}s`;
                    span.classList.add('recharging');
                }
                missileSlotsText.appendChild(span);
            });
            
            if (missilesReadyCount > 0) {
                missileItem.classList.add('ready');
                missileItem.classList.remove('not-ready');
            } else {
                missileItem.classList.remove('ready');
                missileItem.classList.add('not-ready');
            }

            
            // Bomb ability update
            if (bombCount > 0) {
                bombAbilityText.textContent = `(${bombCount}/${MAX_BOMBS})`;
                bombItem.classList.add('ready');
                bombItem.classList.remove('not-ready', 'recharging');
            } else {
                const timeLeftForBomb = Math.ceil((BOMB_CHARGE_INTERVAL - (currentTime - lastBombChargeTime)) / 1000);
                bombAbilityText.textContent = `${timeLeftForBomb}s`; 
                bombItem.classList.remove('ready');
                bombItem.classList.add('not-ready');
            }

            defenseDroneCountText.textContent = `${defenseDrones.length}/${DEFENSE_DRONE_MAX}`;
            if (droneCharge >= DEFENSE_DRONE_COST && defenseDrones.length < DEFENSE_DRONE_MAX) {
                droneDefenseItem.classList.add('ready');
                droneDefenseItem.classList.remove('not-ready');
            } else {
                droneDefenseItem.classList.remove('ready');
                droneDefenseItem.classList.add('not-ready');
            }

            // Rapid Fire update
            if (rapidFireActive) {
                rapidfireStatusText.textContent = `Active`;
                rapidfireItem.classList.add('active');
                rapidfireItem.classList.remove('ready', 'recharging', 'not-ready');
            } else {
                rapidfireStatusText.textContent = 'Inactive';
                rapidfireItem.classList.remove('active', 'ready', 'recharging');
                rapidfireItem.classList.add('not-ready');
            }

            // Triple Shot update
            if (tripleShotActive) {
                tripleshotStatusText.textContent = `Active`;
                tripleshotItem.classList.add('active');
                tripleshotItem.classList.remove('ready', 'recharging', 'not-ready');
            } else {
                tripleshotStatusText.textContent = 'Inactive';
                tripleshotItem.classList.remove('active', 'ready', 'recharging');
                tripleshotItem.classList.add('not-ready');
            }

            // Predator ability update
            const timeSinceLastPredator = currentTime - lastPredatorActivation;
            if (predatorActive) {
                predatorStatusText.textContent = `Active`;
                predatorItem.classList.add('active');
                predatorItem.classList.remove('ready', 'recharging', 'not-ready');
            } else {
                if (timeSinceLastPredator >= PREDATOR_COOLDOWN) {
                    predatorStatusText.textContent = 'Ready';
                    predatorItem.classList.add('ready');
                    predatorItem.classList.remove('active', 'recharging', 'not-ready');
                } else {
                    const timeLeft = Math.ceil((PREDATOR_COOLDOWN - timeSinceLastPredator) / 1000);
                    predatorStatusText.textContent = `${timeLeft}s`;
                    predatorItem.classList.add('recharging');
                    predatorItem.classList.remove('active', 'ready', 'not-ready');
                }
            }

             // Score Multiplier ability update
            const timeSinceLastMultiplier = currentTime - lastScoreMultiplierActivation;
            if (scoreMultiplierActive) {
                scoreMultiplierStatusText.textContent = `Active`;
                scoreMultiItem.classList.add('active');
                scoreMultiItem.classList.remove('ready', 'recharging', 'not-ready');
            } else {
                if (timeSinceLastMultiplier >= SCORE_MULTIPLIER_COOLDOWN) {
                    scoreMultiplierStatusText.textContent = 'Ready';
                    scoreMultiItem.classList.add('ready');
                    scoreMultiItem.classList.remove('active', 'recharging', 'not-ready');
                } else {
                    const timeLeft = Math.ceil((SCORE_MULTIPLIER_COOLDOWN - timeSinceLastMultiplier) / 1000);
                    scoreMultiplierStatusText.textContent = `${timeLeft}s`;
                    scoreMultiItem.classList.add('recharging');
                    scoreMultiItem.classList.remove('active', 'ready', 'not-ready');
                }
            }
        }

        function givePostBossRewards() {
            for (let i = 0; i < 2; i++) {
                if (missileSlots.length < MAX_MISSILES) {
                    missileSlots.push({ readyTime: performance.now() });
                } else {
                    let foundRecharging = false;
                    for (let j = 0; j < missileSlots.length; j++) {
                        if (missileSlots[j].readyTime > performance.now()) { 
                            missileSlots[j].readyTime = performance.now(); 
                            foundRecharging = true;
                            break;
                        }
                    }
                    if (!foundRecharging) {
                        if (missileSlots.length < MAX_MISSILES) {
                            missileSlots.push({ readyTime: performance.now() });
                        }
                    }
                }
            }
            updateMenuDisplay();
        }

        function spawnEnemy() {
            const currentWaveConfig = WAVE_CONFIG[currentWave] || WAVE_CONFIG.default;
            const availableEnemyTypes = currentWaveConfig.enemies;
            
            const eliteEnemiesOnScreen = enemies.filter(e => e.isElite).length;
            const nonEliteEnemiesOnScreen = enemies.filter(e => !e.isElite && !e.isBoss).length;

            let eliteMaxOnScreen = currentWaveConfig.eliteMaxOnScreen;
            if (currentWave > 1) { 
                 eliteMaxOnScreen *= Math.pow(ENEMY_BASE_TYPES['elite'].maxOnScreenMultiplierPerWave, currentWave - 1);
            }
            eliteMaxOnScreen = Math.max(1, eliteMaxOnScreen); 

            let typeToSpawn = '';
            if (eliteEnemiesOnScreen < eliteMaxOnScreen && availableEnemyTypes.includes('elite') && Math.random() < 0.3) { 
                typeToSpawn = 'elite';
            } else if (nonEliteEnemiesOnScreen < currentWaveConfig.maxOnScreen) {
                const nonEliteTypes = availableEnemyTypes.filter(type => !ENEMY_BASE_TYPES[type].isBoss);
                if (nonEliteTypes.length > 0) {
                    typeToSpawn = nonEliteTypes[Math.floor(Math.random() * nonEliteTypes.length)];
                }
            }

            if (typeToSpawn) {
                enemies.push(new Enemy(typeToSpawn, currentWaveConfig.speedMultiplier, currentWaveConfig.hpMultiplier));
            }
        }

        function spawnBoss() {
            drones.forEach(d => d.currentTarget = null); 
            enemies.push(new Enemy('boss', 1 + (currentWave * 0.05), 1 + (currentWave * 0.1)));
            bossActive = true;
            console.log(`Individual boss for wave ${currentWave} appeared!`);
        }
        
        function spawnHunterWave() {
            drones.forEach(d => d.currentTarget = null);
            enemies = []; // Clear all enemies
            enemyBullets = [];
            bossDrones = [];
            
            // Spawn the Hunter
            enemies.push(new Enemy('hunter', 1, 1));
            // Spawn 4 regular bosses
            for(let i = 0; i < 20; i++) {
                enemies.push(new Enemy('boss', 1, 1));
            }
            // Spawn 30 minions
            for(let i = 0; i < 40; i++) {
                enemies.push(new Enemy('hunter_minion'));
            }

            bossActive = true;
            hunterWaveActive = true;
            body.classList.add('apocalypse-active');
            console.log("THE HUNTER HAS ARRIVED!");
        }

         function spawnArtilleryWave() {
            drones.forEach(d => d.currentTarget = null);
            enemies = []; // Clear all enemies
            enemyBullets = [];
            bossDrones = [];
            bossBombs = [];

            enemies.push(new Enemy('artillery_alien', 1, 1));

            bossActive = true;
            console.log("ARTILLERY ALIEN HAS APPEARED!");
        }

        function spawnSkullOverlordWave() {
            drones.forEach(d => d.currentTarget = null);
            enemies = []; // Clear all enemies
            enemyBullets = [];
            bossDrones = [];
            bossBombs = [];

            enemies.push(new Enemy('skull_overlord'));
            for(let i = 0; i < 2; i++) {
                enemies.push(new Enemy('artillery_alien'));
            }
             for(let i = 0; i < 4; i++) {
                enemies.push(new Enemy('boss'));
            }
             for(let i = 0; i < 40; i++) {
                enemies.push(new Enemy('skull_minion'));
            }
            
            bossActive = true;
            body.classList.add('apocalypse-active');
            console.log("THE SKULL OVERLORD HAS ARRIVED!");
        }

        function spawnMegaBossWave() {
            drones.forEach(d => d.currentTarget = null); 
            enemies = enemies.filter(enemy => enemy.isBoss);
            enemyBullets = [];

            for (let i = 0; i < 10; i++) {
                enemies.push(new Enemy('boss', 1 + (currentWave * 0.05), 1 + (currentWave * 0.1)));
            }
            console.log("Mega Boss Wave: 10 bosses appeared!");

            for (let i = 0; i < 30; i++) {
                const randomX = Math.random() * canvas.width;
                const randomY = Math.random() * canvas.height * 0.5;
                bossDrones.push(new BossDrone(randomX, randomY));
            }
            console.log("Mega Boss Wave: 30 attack drones appeared!");

            megaBossWaveActive = true;
            bossActive = true;
        }


        // --- Main Game Loop ---
        function gameLoop(currentTime) {
            if (!currentTime) { 
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }
            if (controlMode === 'mobile' && checkOrientation()) {
                return; 
            }
            if (gameOver) {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                return;
            }

            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;
            
            if (controlMode === 'pc') {
                reticle.style.left = `${mouseX}px`;
                reticle.style.top = `${mouseY}px`;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            stars.forEach(star => {
                star.update(deltaTime);
                star.draw();
            });

            spaceParticles.forEach(sp => {
                sp.update(deltaTime);
                sp.draw();
            });

            if (player) {
                player.update(deltaTime);
                player.draw();
            }

            for (let i = thrustParticles.length - 1; i >= 0; i--) {
                const particle = thrustParticles[i];
                if(particle){
                    particle.update(deltaTime);
                    particle.draw();
                    if (particle.life <= 0 || particle.opacity <= 0 || particle.radius <= 0) {
                        thrustParticles.splice(i, 1);
                    }
                }
            }
            
            // Handle Boss Bombs
            for(let i = bossBombs.length -1; i >= 0; i--) {
                const bomb = bossBombs[i];
                 if(bomb){
                    bomb.update(deltaTime);
                    bomb.draw();
                    if(bomb.state === 'exploded') {
                        bossBombs.splice(i, 1);
                    }
                 }
            }
            
            for(let i = bombFragments.length -1; i>=0; i--){
                const fragment = bombFragments[i];
                if(fragment){
                    fragment.update(deltaTime);
                    fragment.draw();
                    if(checkCollision(player, fragment)){
                        player.takeDamage(1);
                        bombFragments.splice(i,1);
                    } else if (fragment.life <= 0) {
                        bombFragments.splice(i,1);
                    }
                }
            }

            const currentRealTime = performance.now();
            if (shieldActive && currentRealTime - shieldTimer > SHIELD_DURATION) {
                shieldActive = false;
                updateMenuDisplay(); 
            }

            if (predatorActive && currentRealTime - predatorTimer > PREDATOR_DURATION) {
                predatorActive = false;
                updateMenuDisplay();
            }

            if(scoreMultiplierActive && currentRealTime - scoreMultiplierTimer > SCORE_MULTIPLIER_DURATION) {
                scoreMultiplierActive = false;
                updateMenuDisplay();
            }

            if (playerBulletCooldownSlowed && currentRealTime - playerBulletCooldownSlowedTimer > PLAYER_SLOW_BULLET_DURATION) {
                playerBulletCooldownSlowed = false;
                playerBulletCooldown = PLAYER_BASE_BULLET_COOLDOWN;
                updateMenuDisplay();
            } else if (playerBulletCooldownSlowed) {
                playerBulletCooldown = PLAYER_BASE_BULLET_COOLDOWN * PLAYER_SLOW_BULLET_FACTOR;
            }

            if (bombCount < MAX_BOMBS && currentRealTime - lastBombChargeTime > BOMB_CHARGE_INTERVAL) {
                bombCount++;
                lastBombChargeTime = currentRealTime;
            }

            const energyDeltaTime = deltaTime; 
            if (currentEnergy < MAX_ENERGY) {
                currentEnergy = Math.min(MAX_ENERGY, currentEnergy + ENERGY_REGEN_RATE * energyDeltaTime);
            }

            if (player && player.dashActive && currentRealTime - player.dashTimer > DASH_DURATION) {
                player.dashActive = false;
                playerInvulnerable = false;
            }

            if (headShotActive && currentRealTime - headShotTimer > HEAD_SHOT_DURATION) {
                headShotActive = false;
                temporaryDrones = []; // Clear temporary drones
                updateMenuDisplay();
            }

            if (player && ((controlMode === 'pc' && mouseIsDown) || (controlMode === 'mobile' && tapToFireActive)) && currentRealTime - lastPlayerShotTime > playerBulletCooldown) {
                let targetX, targetY;

                if (controlMode === 'mobile') {
                    let closestEnemy = null;
                    let minDist = Infinity;
                    const autoAimRadius = 400;
                    enemies.forEach(enemy => {
                        const dist = Math.hypot(player.x + player.width / 2 - (enemy.x + enemy.width / 2),
                                                player.y + player.height / 2 - (enemy.y + enemy.height / 2));
                        if (dist < minDist && dist < autoAimRadius) {
                            minDist = dist;
                            closestEnemy = enemy;
                        }
                    });

                    if (closestEnemy) {
                        targetX = closestEnemy.x + closestEnemy.width / 2;
                        targetY = closestEnemy.y + closestEnemy.height / 2;
                    } else {
                        targetX = tapToFireTargetX;
                        targetY = tapToFireTargetY;
                    }
                } else {
                    targetX = mouseX;
                    targetY = mouseY;
                }

                const bulletStartX = player.x + player.width / 2 + Math.cos(player.angle) * (player.height / 2);
                const bulletStartY = player.y + player.height / 2 + Math.sin(player.angle) * (player.height / 2);

                if (tripleShotActive) {
                    const spread = Math.PI / 10; 
                    for (let i = -1; i <= 1; i++) {
                        const angle = player.angle + i * spread;
                        bullets.push(new Bullet(bulletStartX, bulletStartY,
                                                bulletStartX + Math.cos(angle) * 100,
                                                bulletStartY + Math.sin(angle) * 100,
                                                PLAYER_BULLET_SPEED, '#66FFFF'));
                    }
                } else if (predatorActive) { 
                    const baseAngle = player.angle - (PREDATOR_BULLET_SPREAD / 2);
                    const angleIncrement = PREDATOR_BULLET_SPREAD / (PREDATOR_BULLET_COUNT - 1);
                    for (let i = 0; i < PREDATOR_BULLET_COUNT; i++) {
                        const angle = baseAngle + i * angleIncrement;
                        bullets.push(new Bullet(bulletStartX, bulletStartY,
                                                bulletStartX + Math.cos(angle) * 100,
                                                bulletStartY + Math.sin(angle) * 100,
                                                PLAYER_BULLET_SPEED, '#FFD700'));
                    }
                } else {
                    bullets.push(new Bullet(bulletStartX, bulletStartY, targetX, targetY, PLAYER_BULLET_SPEED, '#66FFFF'));
                }
                lastPlayerShotTime = currentRealTime;
            }

            [...drones, ...temporaryDrones].forEach(drone => {
                if (drone) {
                    drone.update(deltaTime);
                    drone.draw();
                }
            });

            defenseDrones.forEach(dDrone => { 
                dDrone.update(deltaTime);
                dDrone.draw();
            });

            if (specialDrone) { 
                specialDrone.update(deltaTime);
                specialDrone.draw();
            }

            for (let i = bossDrones.length - 1; i >= 0; i--) {
                const bDrone = bossDrones[i];
                 if(bDrone){
                    bDrone.update(deltaTime);
                    bDrone.draw();

                    if (player && checkCollision(player, bDrone)) {
                        player.takeDamage(1); 
                        createExplosion(bDrone.x, bDrone.y, bDrone.color, 10, 200, 2.5, 1, 3); 
                        bossDrones.splice(i, 1);
                    }
                 }
            }


            for (let i = pickups.length - 1; i >= 0; i--) {
                const pickup = pickups[i];
                 if(pickup){
                    pickup.update(deltaTime);
                    pickup.draw();

                    if (player && checkCollision(player, pickup)) {
                        switch(pickup.type) {
                            case 'life':
                                if (lives < maxLives) lives++;
                                break;
                            case 'shield':
                                shieldActive = true;
                                shieldTimer = currentRealTime;
                                lastShieldActivation = currentRealTime - (SHIELD_COOLDOWN - COLLECTED_SHIELD_DURATION);
                                break;
                            case 'drone':
                                if (drones.length < DRONE_MAX_DRONES) {
                                    let nextOffsetIndex = 0;
                                    let foundSlot = false;
                                    for (let j = 0; j < DRONE_OFFSETS.length; j++) {
                                        if (!drones.some(d => d.offsetIndex === j)) {
                                            nextOffsetIndex = j;
                                            foundSlot = true;
                                            break;
                                        }
                                    }
                                    if (foundSlot) {
                                        drones.push(new Drone(nextOffsetIndex));
                                    }
                                }
                                break;
                            case 'missile':
                                let foundMissileSlotToSpeedUp = false;
                                for (let j = 0; j < missileSlots.length; j++) {
                                    if (missileSlots[j].readyTime > currentTime) { 
                                        missileSlots[j].readyTime = currentTime; 
                                        foundMissileSlotToSpeedUp = true;
                                        break;
                                    }
                                }
                                if (!foundMissileSlotToSpeedUp && missileSlots.length < MAX_MISSILES) {
                                    missileSlots.push({ readyTime: currentTime }); 
                                }
                                break;
                            case 'rapidfire':
                                rapidFireActive = true;
                                rapidFireTimer = currentRealTime;
                                playerBulletCooldown = PLAYER_BASE_BULLET_COOLDOWN * RAPID_FIRE_COOLDOWN_FACTOR;
                                break;
                            case 'tripleshot':
                                tripleShotActive = true;
                                tripleShotTimer = currentRealTime;
                                break;
                        }
                        createExplosion(pickup.x, pickup.y, pickup.color, 5, 100, 3, 1, 2); 
                        pickups.splice(i, 1);
                        updateMenuDisplay();
                    } else if (pickup.y > canvas.height + pickup.height) { 
                        pickups.splice(i, 1);
                    }
                 }
            }

            if (rapidFireActive && currentRealTime - rapidFireTimer > RAPID_FIRE_DURATION) {
                rapidFireActive = false;
                playerBulletCooldown = PLAYER_BASE_BULLET_COOLDOWN; 
            }
            if (tripleShotActive && currentRealTime - tripleShotTimer > TRIPLE_SHOT_DURATION) {
                tripleShotActive = false;
            }


            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                 if(bullet) {
                    bullet.update(deltaTime);
                    bullet.draw();

                    let bulletHit = false;

                    if (bullet.isPlayerBullet) {
                        for (let bdIndex = bossDrones.length - 1; bdIndex >= 0; bdIndex--) {
                            const bDrone = bossDrones[bdIndex];
                            if (checkCollision(bullet, bDrone)) {
                                if (bDrone.takeDamage(PLAYER_BULLET_DAMAGE)) { 
                                    createExplosion(bDrone.x, bDrone.y, bDrone.color, 10, 200, 2.5, 1, 3); 
                                    bossDrones.splice(bdIndex, 1);
                                }
                                bullets.splice(i, 1);
                                bulletHit = true;
                                break;
                            }
                        }
                        if (bulletHit) continue;


                        for (let eIndex = enemies.length - 1; eIndex >= 0; eIndex--) {
                            const enemy = enemies[eIndex];
                            if (checkCollision(bullet, enemy)) {
                                if (bullet.isExplosive) { 
                                    createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 'red', 25, 400, 1.5, 2, 6); 
                                    bullet.collided = true; 

                                    const explosionCenter = { x: enemy.x + enemy.width / 2, y: enemy.y + enemy.height / 2 };
                                    const effectiveExplosionRadius = bullet.explosionRadius > 0 ? bullet.explosionRadius : EXPLOSION_RADIUS;
                                    
                                    const enemiesHitByExplosion = [];
                                    for (let otherEnemy of enemies) {
                                        const otherEnemyCenterX = otherEnemy.x + otherEnemy.width / 2;
                                        const otherEnemyCenterY = otherEnemy.y + otherEnemy.height / 2;
                                        const distFromHit = Math.hypot(explosionCenter.x - otherEnemyCenterX, explosionCenter.y - otherEnemyCenterY);
                                        
                                        if (distFromHit < effectiveExplosionRadius) {
                                            enemiesHitByExplosion.push(otherEnemy);
                                        }
                                    }

                                    for(let otherEnemy of enemiesHitByExplosion) {
                                        let damageAmount;
                                        if (otherEnemy.missileDamageMultiplier) {
                                            damageAmount = otherEnemy.maxHp * otherEnemy.missileDamageMultiplier;
                                        } else if (bullet.damageAmount > 0) {
                                            damageAmount = bullet.damageAmount;
                                        } else {
                                            damageAmount = PLAYER_MISSILE_HACKER_EXPLOSION_DAMAGE;
                                        }

                                        if (otherEnemy.takeDamage(damageAmount)) {
                                            const idx = enemies.indexOf(otherEnemy);
                                            if (idx > -1) {
                                                createExplosion(otherEnemy.x + otherEnemy.width / 2, otherEnemy.y + otherEnemy.height / 2, 'orange', 15, 280, 2, 1.5, 4); 
                                                
                                                if (otherEnemy.type === 'exploder' && otherEnemy.explosionDamage > 0) {
                                                    createExplosion(otherEnemy.x + otherEnemy.width / 2, otherEnemy.y + otherEnemy.height / 2, otherEnemy.color, 35, 600, 1.5, 3, 8); 
                                                    player.takeDamage(otherEnemy.explosionDamage); 
                                                }

                                                addScore(otherEnemy.scoreValue); 
                                                droneCharge += otherEnemy.droneChargeValue;

                                                enemies.splice(idx, 1);
                                                
                                                if (otherEnemy.isBoss) {
                                                    if(otherEnemy.type === 'hunter' || otherEnemy.type === 'artillery_alien' || otherEnemy.type === 'skull_overlord') {
                                                        hunterWaveActive = false;
                                                        body.classList.remove('apocalypse-active');
                                                    }
                                                    
                                                    lives += 10; 
                                                    if (!specialDrone) specialDrone = new SpecialDrone(); 
                                                    
                                                    if (enemies.filter(e => e.isBoss).length === 0) { 
                                                        megaBossWaveActive = false; 
                                                        bossActive = false;
                                                        bossDrones = [];
                                                    }
                                                    givePostBossRewards(); 
                                                }
                                            }
                                        }
                                    }

                                } else {
                                    let damageToDeal = PLAYER_BULLET_DAMAGE;
                                    if (enemy.isBoss) {
                                        damageToDeal = enemy.maxHp * PLAYER_BULLET_DAMAGE_BOSS_COMMON;
                                    }

                                    if (enemy.takeDamage(damageToDeal)) { 
                                        createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 'orange', 15, 200, 2, 1, 3); 
                                        
                                        if (enemy.type === 'exploder' && enemy.explosionDamage > 0) {
                                            createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.color, 35, 600, 1.5, 3, 8); 
                                            player.takeDamage(enemy.explosionDamage); 
                                        }
                                        
                                        addScore(enemy.scoreValue); 
                                        droneCharge += enemy.droneChargeValue;
                                        const isLastBoss = enemy.isBoss && enemies.filter(e => e.isBoss).length === 1;

                                        enemies.splice(eIndex, 1);

                                        if (enemy.isBoss) {
                                            if(enemy.type === 'hunter' || enemy.type === 'artillery_alien' || enemy.type === 'skull_overlord') {
                                                hunterWaveActive = false;
                                                body.classList.remove('apocalypse-active');
                                            }

                                            lives += 10;
                                            if (!specialDrone) specialDrone = new SpecialDrone();
                                            
                                            if (isLastBoss && enemies.filter(e => e.isBoss).length === 0) { 
                                                megaBossWaveActive = false; 
                                                bossActive = false;
                                                bossDrones = [];
                                            }
                                            givePostBossRewards(); 
                                        } else {
                                            dropItem(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                                        }
                                    }
                                }
                                bullets.splice(i, 1); 
                                bulletHit = true;
                                break; 
                            }
                        }
                    }
                    
                    if (bulletHit) continue; 

                    if (bullet.x < -bullet.radius || bullet.x > canvas.width + bullet.radius ||
                        bullet.y < -bullet.radius || bullet.y > canvas.height + bullet.radius) {
                        bullets.splice(i, 1);
                    }
                 }
            }

            const currentWaveConfig = WAVE_CONFIG[currentWave] || WAVE_CONFIG.default;
            
            // Only spawn normal enemies if no active bosses
            if (currentRealTime - lastEnemySpawnTime > currentWaveConfig.spawnRate && !bossActive) {
                 let spawnCount = isChallengeMode ? 5 + Math.floor(currentWave / 2) : 5;
                for (let i = 0; i < spawnCount; i++) {
                    spawnEnemy();
                }
                lastEnemySpawnTime = currentRealTime;
            }
            

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if(!enemy) continue;
                enemy.update(deltaTime);
                enemy.draw();

                if (player && checkCollision(player, enemy)) {
                    if (enemy.isBoss) {
                         const now = performance.now();
                        if (enemy.type === 'hunter' && now - (player.lastHunterDamageTime || 0) > 1000) {
                             player.takeDamage(10);
                             player.lastHunterDamageTime = now;
                        } else {
                            lives = 0;
                            gameOver = true;
                            endGame();
                            return;
                        }
                    } else if (enemy.type === 'exploder' && enemy.explosionDamage > 0) {
                        createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.color, 35, 600, 1.5, 3, 8); 
                        player.takeDamage(enemy.explosionDamage);
                    } else { 
                        player.takeDamage(1);
                    }
                    createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 'orange', 15, 280, 2, 1.5, 4); 
                    enemies.splice(i, 1);
                    addScore(enemy.scoreValue / 2); 
                    droneCharge += enemy.droneChargeValue / 2;
                }
            }

            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                if(bullet) {
                    bullet.update(deltaTime);
                    bullet.draw();

                    let bulletHit = false;

                    for (let ddIndex = defenseDrones.length - 1; ddIndex >= 0; ddIndex--) {
                        const dDrone = defenseDrones[ddIndex];
                        if (checkCollision(bullet, dDrone)) {
                            if (dDrone.takeDamage(100)) { 
                                createExplosion(dDrone.x, dDrone.y, '#B22222', 10, 250, 2.5, 1, 3); 
                                defenseDrones.splice(ddIndex, 1);
                            }
                            enemyBullets.splice(i, 1);
                            bulletHit = true;
                            break;
                        }
                    }
                    if (bulletHit) continue;

                    if (specialDrone && checkCollision(bullet, specialDrone)) {
                        if (specialDrone.takeDamage(100)) { 
                            createExplosion(specialDrone.x, specialDrone.y, specialDrone.color, 10, 250, 2.5, 1, 3); 
                            specialDrone = null;
                        }
                        enemyBullets.splice(i, 1);
                        bulletHit = true;
                    }
                    if (bulletHit) continue;
                    
                   
                    for (let dIndex = drones.length - 1; dIndex >= 0; dIndex--) {
                        const drone = drones[dIndex];
                        if (checkCollision(bullet, drone)) {
                            if (drone.takeDamage(PLAYER_BULLET_DAMAGE / 2)) { 
                                createExplosion(drone.x, drone.y, 'gray', 10, 250, 2.5, 1, 3); 
                                drones.splice(dIndex, 1);
                            }
                            enemyBullets.splice(i, 1);
                            bulletHit = true;
                            break;
                        }
                    }
                    
                    if (bulletHit) continue;


                    if (player && checkCollision(bullet, player)) {
                        if (bullet.shieldBreaker && shieldActive) {
                            shieldActive = false;
                            createExplosion(player.x + player.width/2, player.y + player.height/2, 'rgba(0, 150, 255, 0.5)', 15, 300, 2, 1.5, 4);
                        }

                        if (bullet.isExplosive) { 
                            createExplosion(bullet.x, bullet.y, bullet.color, 15, 300, 2, 1.5, 4); 
                            player.takeDamage(2); 
                        } else if (bullet.isDebuff) { 
                            playerBulletCooldownSlowed = true;
                            playerBulletCooldownSlowedTimer = currentRealTime;
                            createExplosion(bullet.x, bullet.y, bullet.color, 5, 120, 3, 0.8, 2); 
                            player.takeDamage(0); 
                        } else if (bullet.damagePercent > 0) { 
                            const damage = Math.ceil(lives * bullet.damagePercent);
                            player.takeDamage(damage);
                        } else { 
                            player.takeDamage(1); 
                        }
                        createExplosion(bullet.x, bullet.y, 'red', 8, 160, 2.5, 1, 2); 
                        enemyBullets.splice(i, 1);
                        bulletHit = true;
                    }
                    
                    if (bulletHit) continue;

                    if (bullet.x < -bullet.radius || bullet.x > canvas.width + bullet.radius ||
                        bullet.y < -bullet.radius || bullet.y > canvas.height + bullet.radius) {
                        enemyBullets.splice(i, 1);
                    }
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                 if(particle) {
                    particle.update(deltaTime);
                    particle.draw();
                    if (particle.life <= 0 || particle.opacity <= 0 || particle.radius <= 0) { 
                        particles.splice(i, 1);
                    }
                 }
            }
            
            if (hunterWaveActive) {
                const pulse = Math.abs(Math.sin(performance.now() * 0.012)); // Faster, more intense pulse
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const innerRadius = 150 - pulse * 80; // More pronounced change
                const outerRadius = canvas.width;

                let gradient = ctx.createRadialGradient(centerX, centerY, innerRadius, centerX, centerY, outerRadius);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(0.7, 'rgba(120, 0, 0, 0.9)'); // Darker, more saturated red
                gradient.addColorStop(1, 'rgba(0, 0, 0, 1)'); // Pitch black at the edges

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            updateMenuDisplay();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function dropItem(x, y) {
            const roll = Math.random();
            let cumulativeChance = 0;
            // Add a chance to drop a life
            const lifeDropChance = Math.random() * 0.03 + 0.01; // 1% to 4%
            if (Math.random() <= lifeDropChance) {
                pickups.push(new Pickup(x, y, 'life'));
                return;
            }

            for (const type in DROP_CHANCE) {
                cumulativeChance += DROP_CHANCE[type];
                if (roll < cumulativeChance) {
                    pickups.push(new Pickup(x, y, type));
                    return;
                }
            }
        }

        function checkCollision(obj1, obj2) {
            if(!obj1 || !obj2) return false;
            const obj1IsCircle = obj1.radius !== undefined;
            const obj2IsCircle = obj2.radius !== undefined;

            if (obj1IsCircle && obj2IsCircle) {
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (obj1.radius + obj2.radius);
            } else if (obj1IsCircle && !obj2IsCircle) {
                const closestX = Math.max(obj2.x, Math.min(obj1.x, obj2.x + obj2.width));
                const closestY = Math.max(obj2.y, Math.min(obj1.y, obj2.y + obj2.height));
                const dx = obj1.x - closestX;
                const dy = obj1.y - closestY;
                return (dx * dx + dy * dy) < (obj1.radius * obj1.radius);
            } else if (!obj1IsCircle && obj2IsCircle) {
                const closestX = Math.max(obj1.x, Math.min(obj2.x, obj1.x + obj1.width));
                const closestY = Math.max(obj1.y, Math.min(obj2.y, obj1.y + obj1.height));
                const dx = obj2.x - closestX;
                const dy = obj2.y - closestY;
                return (dx * dx + dy * dy) < (obj2.radius * obj2.radius);
            } else {
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + obj1.height > obj2.y;
            }
        }


        // --- Event Listeners ---
        document.addEventListener('keydown', (e) => {
            if (gameOver || !player) return;

            switch (e.key.toLowerCase()) {
                case 'w': keys.w = true; break;
                case 'a': keys.a = true; break;
                case 's': keys.s = true; break;
                case 'd': keys.d = true; break;
                case 'shift': keys.shift = true; break;
                case 'q':
                    const currentRealTimeShield = performance.now();
                    if (currentRealTimeShield - lastShieldActivation >= SHIELD_COOLDOWN) {
                        shieldActive = true;
                        shieldTimer = currentRealTimeShield;
                        lastShieldActivation = currentRealTimeShield;
                        updateMenuDisplay();
                    }
                    break;
                case 'e': 
                    if (player && !player.dashActive && currentEnergy >= DASH_COST) {
                        player.dashActive = true;
                        playerInvulnerable = true; 
                        player.dashTimer = performance.now();
                        currentEnergy -= DASH_COST;
                        createExplosion(player.x + player.width / 2, player.y + player.height / 2, 'lightblue', 10, 300, 2, 1.5, 4); 
                        updateMenuDisplay();
                    }
                    break;
                case 'f':
                    if (player && droneCharge >= DRONE_ACTIVATION_COST && drones.length < DRONE_MAX_DRONES) {
                        let nextOffsetIndex = 0;
                        let foundSlot = false;
                        for (let i = 0; i < DRONE_OFFSETS.length; i++) {
                            if (!drones.some(d => d.offsetIndex === i)) {
                                nextOffsetIndex = i;
                                foundSlot = true;
                                break;
                            }
                        }
                        if (foundSlot) {
                            drones.push(new Drone(nextOffsetIndex));
                            droneCharge -= DRONE_ACTIVATION_COST;
                            updateMenuDisplay();
                        }
                    }
                    break;
                case 'g':
                    const currentTimeMissile = performance.now();
                    let missileSlotIndex = -1;
                    for (let i = 0; i < missileSlots.length; i++) {
                        if (missileSlots[i].readyTime <= currentTimeMissile) {
                            missileSlotIndex = i;
                            break;
                        }
                    }

                    if (missileSlotIndex !== -1) {
                        const missileStartX = player.x + player.width / 2 + Math.cos(player.angle) * (player.height / 2);
                        const missileStartY = player.y + player.height / 2 + Math.sin(player.angle) * (player.height / 2);
                        bullets.push(new Bullet(missileStartX, missileStartY, mouseX, mouseY, MISSILE_HACKER_SPEED, 'purple', true, true, true, 0, EXPLOSION_RADIUS, 0)); 
                        
                        missileSlots[missileSlotIndex].readyTime = currentTimeMissile + MISSILE_COOLDOWN_PER_SLOT;
                        updateMenuDisplay();
                    }
                    break;
                case 'c': 
                    if (droneCharge >= DEFENSE_DRONE_COST && defenseDrones.length < DEFENSE_DRONE_MAX) {
                        let nextIndex = -1;
                        for (let i = 0; i < DEFENSE_DRONE_MAX; i++) {
                            if (!defenseDrones.some(d => d.index === i)) {
                                nextIndex = i;
                                break;
                            }
                        }
                        if (nextIndex !== -1) {
                            defenseDrones.push(new DefenseDrone(nextIndex));
                            droneCharge -= DEFENSE_DRONE_COST;
                            updateMenuDisplay();
                        }
                    }
                    break;
                case 't': 
                    if(!isChallengeMode && scoreMultiItem.style.display !== 'none') {
                        const currentRealTimeT = performance.now();
                        if (currentRealTimeT - lastScoreMultiplierActivation >= SCORE_MULTIPLIER_COOLDOWN) {
                            scoreMultiplierActive = true;
                            scoreMultiplierTimer = currentRealTimeT;
                            lastScoreMultiplierActivation = currentRealTimeT;
                            updateMenuDisplay();
                        }
                    }
                    break;
                 case 'v':
                    const currentTimeHeadshot = performance.now();
                    if (headShotAvailable && currentTimeHeadshot - lastHeadShotActivation >= headShotCooldown) {
                        headShotActive = true;
                        headShotTimer = currentTimeHeadshot;
                        lastHeadShotActivation = currentTimeHeadshot;
                        headShotCooldown *= HEAD_SHOT_COOLDOWN_INCREASE;
                        
                        for(let i=0; i<30; i++) {
                            temporaryDrones.push(new Drone(i, true, HEAD_SHOT_DURATION));
                        }
                        updateMenuDisplay();
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (gameOver || !player) return;

            switch (e.key.toLowerCase()) {
                case 'w': keys.w = false; break;
                case 'a': keys.a = false; break;
                case 's': keys.s = false; break;
                case 'd': keys.d = false; break;
                case 'shift': keys.shift = false; break;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (controlMode === 'pc') {
                mouseX = e.clientX;
                mouseY = e.clientY;
            }
        });

        document.addEventListener('mousedown', (e) => {
            if (controlMode !== 'pc') return;

            if (e.button === 0 && !gameOver) {
                mouseIsDown = true; 
            } else if (e.button === 2 && !gameOver) {
                const currentTime = performance.now();
                if (currentTime - lastPredatorActivation >= PREDATOR_COOLDOWN) {
                    predatorActive = true;
                    predatorTimer = currentTime;
                    lastPredatorActivation = currentTime;
                    updateMenuDisplay();
                }
                e.preventDefault(); 
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (controlMode !== 'pc') return;

            if (e.button === 0) {
                mouseIsDown = false; 
            }
        });

        document.addEventListener('wheel', (e) => {
            if (gameOver || controlMode !== 'pc') return;

            if (bombCount > 0) { 
                createExplosion(canvas.width / 2, canvas.height / 2, '#8B008B', BOMB_EXPLOSION_PARTICLE_COUNT, 1000, 1.5, 8, 30, true); 
                enemies = enemies.filter(enemy => enemy.isBoss); 
                enemyBullets = []; 
                bombCount--; 
                updateMenuDisplay();
            }
            e.preventDefault(); 
        }, { passive: false }); 

        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });


        // Event listeners for control mode selection buttons
        playNormalPcButton.addEventListener('click', () => {
             startGame('pc', false);
        });

        playNormalMobileButton.addEventListener('click', () => {
            startGame('mobile', false);
        });

        challengeButton.addEventListener('click', () => {
            challengeModal.style.display = 'flex';
        });

        confirmChallengePcButton.addEventListener('click', () => {
            challengeModal.style.display = 'none';
            startGame('pc', true);
        });
        
        confirmChallengeMobileButton.addEventListener('click', () => {
            challengeModal.style.display = 'none';
            startGame('mobile', true);
        });
        
        cancelChallengeButton.addEventListener('click', () => {
            challengeModal.style.display = 'none';
        });


        tutorialButton.addEventListener('click', () => showScreen('tutorial'));
        backToMainButton.addEventListener('click', () => showScreen('main'));
        restartGameButton.addEventListener('click', () => startGame(controlMode, isChallengeMode)); 
        backToMainFromGameoverButton.addEventListener('click', () => showScreen('main')); 

        // Initial setup on window load
        window.addEventListener('load', () => {
            showScreen('main');
        });
        window.addEventListener('resize', () => {
            resizeCanvas();
            if (controlMode === 'mobile') {
                checkOrientation();
            }
            updateMenuDisplay();
        });


        // --- Mobile Touch Controls ---

        if (joystickArea) { 
            joystickArea.addEventListener('touchstart', (e) => {
                if (controlMode !== 'mobile' || gameOver) return;
                e.preventDefault(); 

                const touch = e.touches[0];
                const rect = joystickArea.getBoundingClientRect();
                joystickCenterX = rect.left + rect.width / 2;
                joystickCenterY = rect.top + rect.height / 2;

                joystickActive = true;
                joystickInner.classList.add('active');
                joystickArea.classList.add('active');
                updateJoystick(touch.clientX, touch.clientY);
            }, { passive: false });

            joystickArea.addEventListener('touchmove', (e) => {
                if (controlMode !== 'mobile' || gameOver || !joystickActive) return;
                e.preventDefault();

                const touch = e.touches[0];
                updateJoystick(touch.clientX, touch.clientY);
            }, { passive: false });

            joystickArea.addEventListener('touchend', (e) => {
                if (controlMode !== 'mobile' || gameOver) return;

                joystickActive = false;
                joystickInner.style.transform = `translate(0px, 0px)`;
                joystickInner.classList.remove('active');
                joystickArea.classList.remove('active');
                joystickDeltaX = 0;
                joystickDeltaY = 0;
            });
        }

        function updateJoystick(touchX, touchY) {
            let dx = touchX - joystickCenterX;
            let dy = touchY - joystickCenterY;
            const distance = Math.hypot(dx, dy);

            if (distance < JOYSTICK_DEADZONE) {
                dx = 0;
                dy = 0;
            } else if (distance > JOYSTICK_MAX_DIST) {
                dx = dx / distance * JOYSTICK_MAX_DIST;
                dy = dy / distance * JOYSTICK_MAX_DIST;
            }

            joystickInner.style.transform = `translate(${dx}px, ${dy}px)`;
            joystickDeltaX = dx;
            joystickDeltaY = dy;
        }

        if (tapToFireArea) {
            tapToFireArea.addEventListener('touchstart', (e) => {
                if (controlMode !== 'mobile' || gameOver) return;
                e.preventDefault(); 
                const touch = e.touches[0];
                tapToFireActive = true;
                tapToFireTargetX = touch.clientX;
                tapToFireTargetY = touch.clientY;
            }, { passive: false });

            tapToFireArea.addEventListener('touchmove', (e) => {
                if (controlMode !== 'mobile' || gameOver || !tapToFireActive) return;
                e.preventDefault(); 
                const touch = e.touches[0];
                tapToFireTargetX = touch.clientX;
                tapToFireTargetY = touch.clientY;
            }, { passive: false });

            tapToFireArea.addEventListener('touchend', (e) => {
                if (controlMode !== 'mobile' || gameOver) return;
                tapToFireActive = false;
            }, { passive: false });
        }


        // Mobile Ability Buttons
        const allAbilityButtons = [
            btnShield, btnDash, btnCombatDrone, btnMissile, 
            btnDefenseDrone, btnMultiplier, btnPredator, btnBomb
        ];

        allAbilityButtons.forEach(button => {
            if (button) {
                button.addEventListener('touchstart', (e) => {
                    if (controlMode !== 'mobile' || gameOver) return;
                    e.preventDefault();
                    
                    const currentTime = performance.now();
                    // Activate abilities based on button ID
                    switch(button.id) {
                         case 'btn-shield':
                            if (currentTime - lastShieldActivation >= SHIELD_COOLDOWN) {
                                shieldActive = true;
                                shieldTimer = currentTime;
                                lastShieldActivation = currentTime;
                                updateMenuDisplay();
                            }
                            break;
                        case 'btn-dash':
                            if (player && !player.dashActive && currentEnergy >= DASH_COST) {
                                player.dashActive = true;
                                playerInvulnerable = true; 
                                player.dashTimer = currentTime;
                                currentEnergy -= DASH_COST;
                                if (Math.hypot(joystickDeltaX, joystickDeltaY) > JOYSTICK_DEADZONE) {
                                    player.angle = Math.atan2(joystickDeltaY, joystickDeltaX);
                                } else {
                                    player.angle = -Math.PI / 2;
                                }
                                createExplosion(player.x + player.width / 2, player.y + player.height / 2, 'lightblue', 10, 300, 2, 1.5, 4); 
                                updateMenuDisplay();
                            }
                            break;
                        case 'btn-combat-drone':
                             if (player && droneCharge >= DRONE_ACTIVATION_COST && drones.length < DRONE_MAX_DRONES) {
                                let nextOffsetIndex = 0;
                                let foundSlot = false;
                                for (let i = 0; i < DRONE_OFFSETS.length; i++) {
                                    if (!drones.some(d => d.offsetIndex === i)) {
                                        nextOffsetIndex = i;
                                        foundSlot = true;
                                        break;
                                    }
                                }
                                if (foundSlot) {
                                    drones.push(new Drone(nextOffsetIndex));
                                    droneCharge -= DRONE_ACTIVATION_COST;
                                    updateMenuDisplay();
                                }
                            }
                            break;
                         case 'btn-missile':
                            let missileSlotIndex = -1;
                            for (let i = 0; i < missileSlots.length; i++) {
                                if (missileSlots[i].readyTime <= currentTime) {
                                    missileSlotIndex = i;
                                    break;
                                }
                            }
                            if (missileSlotIndex !== -1) {
                                const missileStartX = player.x + player.width / 2 + Math.cos(player.angle) * (player.height / 2);
                                const missileStartY = player.y + player.height / 2 + Math.sin(player.angle) * (player.height / 2);
                                bullets.push(new Bullet(missileStartX, missileStartY, 0, 0, MISSILE_HACKER_SPEED, 'purple', true, true, true, 0, EXPLOSION_RADIUS, 0));
                                missileSlots[missileSlotIndex].readyTime = currentTime + MISSILE_COOLDOWN_PER_SLOT;
                                updateMenuDisplay();
                            }
                            break;
                        case 'btn-defense-drone':
                            if (droneCharge >= DEFENSE_DRONE_COST && defenseDrones.length < DEFENSE_DRONE_MAX) {
                                let nextIndex = -1;
                                for (let i = 0; i < DEFENSE_DRONE_MAX; i++) {
                                    if (!defenseDrones.some(d => d.index === i)) {
                                        nextIndex = i;
                                        break;
                                    }
                                }
                                if (nextIndex !== -1) {
                                    defenseDrones.push(new DefenseDrone(nextIndex));
                                    droneCharge -= DEFENSE_DRONE_COST;
                                    updateMenuDisplay();
                                }
                            }
                            break;
                        case 'btn-multiplier':
                             if(!isChallengeMode && scoreMultiItem.style.display !== 'none') {
                                if (currentTime - lastScoreMultiplierActivation >= SCORE_MULTIPLIER_COOLDOWN) {
                                    scoreMultiplierActive = true;
                                    scoreMultiplierTimer = currentTime;
                                    lastScoreMultiplierActivation = currentTime;
                                    updateMenuDisplay();
                                }
                             }
                            break;
                        case 'btn-predator':
                             if (currentTime - lastPredatorActivation >= PREDATOR_COOLDOWN) {
                                predatorActive = true;
                                predatorTimer = currentTime;
                                lastPredatorActivation = currentTime;
                                updateMenuDisplay();
                            }
                            break;
                         case 'btn-bomb':
                            if (bombCount > 0) { 
                                createExplosion(canvas.width / 2, canvas.height / 2, '#8B008B', BOMB_EXPLOSION_PARTICLE_COUNT, 1000, 1.5, 8, 30, true); 
                                enemies = enemies.filter(enemy => enemy.isBoss); 
                                enemyBullets = []; 
                                bombCount--; 
                                updateMenuDisplay(); 
                            }
                            break;
                    }
                }, { passive: false });
            }
        });
    </script>
</body>
</html>
